<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Yeonon&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            C++新特性梳理系列：C++11 移动语义和完美转发
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C++11之前，如果不使用指针或者引用的场景下，发生了类对象之间发生转移的操作，几乎可以肯定都会触发一次类对象的拷贝。如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        :m_name(name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; person) </span><br><span class="line">    &#123;</span><br><span class="line">        m_name = person.m_name;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::ctor was called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonName</span><span class="params">(Person person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonName2</span><span class="params">(Person&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonName3</span><span class="params">(Person* person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; person-&gt;name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"yeonon"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p)</span></span>; <span class="comment">//ctor</span></span><br><span class="line">    printPersonName(p2); <span class="comment">// will print "Person::ctor was called"</span></span><br><span class="line">    printPersonName2(p2); <span class="comment">// will not print "Person::ctor was called"</span></span><br><span class="line">    printPersonName3(&amp;p2); <span class="comment">// will not print "Person::ctor was called"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里p2的初始化触发了一次拷贝构造,printPersonName是按值传递参数的，所以也触发了一次拷贝构造，printPersonName2和printPersonName3是按引用或者指针传递的（都有发生拷贝，但不是对象的拷贝），没有触发拷贝构造。这就有朋友要问了，那只用引用或者指针移动对象不就可以避免无效拷贝了吗？在上面的例子中，是的。但并不是任何场景都可以使用指针或者引用的。例如把对象放到容器中，看下例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_name == p.m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(p.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"yeonon"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"yeonon1"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"yeonon2"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"yeonon3"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> Person&amp;, <span class="built_in">std</span>::<span class="built_in">string</span>, hashName&gt; m;</span><br><span class="line">    m[p] = <span class="string">"yeonon"</span>;</span><br><span class="line">    m[p1] = <span class="string">"yeonon1"</span>;</span><br><span class="line">    m[p2] = <span class="string">"yeonon3"</span>;</span><br><span class="line">    m[p3] = <span class="string">"yeonon4"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，代码中unordered_map的key是引用，目的是为了防止拷贝。但这样的代码其实在第8行就已经有编译报错了。为什么？因为unordered_map的key必须是一个可hash的，而引用是没有实体类型的，所以无法完成hash计算。在C++11之的解决办法是：自定义一个hash函数，并且在hash函数内部对Person执行解引用的操作。</p>
<p>而到了C++11，至少有两种方法解决。</p>
<ol>
<li>使用std:reference_wrapper<T>来套一层。std:reference_wrapper不会发生拷贝。</li>
<li>利用移动语义。</li>
</ol>
<p>其实std:reference_wrapper也涉及移动语义，不过在这里先按下不表。直接来看一个使用std:reference_wrapper的例子吧:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_name == p.m_name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"yeonon"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"yeonon1"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"yeonon2"</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"yeonon3"</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::reference_wrapper&lt;Person&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>, hashName, <span class="built_in">std</span>::equal_to&lt;Person&gt;&gt; m;</span><br><span class="line">    m[p] = <span class="string">"yeonon"</span>;</span><br><span class="line">    m[p1] = <span class="string">"yeonon1"</span>;</span><br><span class="line">    m[p2] = <span class="string">"yeonon3"</span>;</span><br><span class="line">    m[p3] = <span class="string">"yeonon4"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unordered_map的第四个模板参数是一个equal函数，由于reference_wrapper虽然本身定义了operator==，但不会转发到person，所以需要我们显示提供一个operator ==，标准库的std::euqal_to<T>可以帮助我们实现这样一个可调用对象。好了，编译运行上面的代码，就可以发现没有Person::ctor被调用了。所以，我们成功了！</p>
<p>使用reference_wrapper还是相对比较麻烦了，直接使用右值引用和std::move就可以实现目标，关于右值引用和std::move是什么，后面会细说。这里先来看解决方案:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> Person&amp;&amp;, <span class="built_in">std</span>::<span class="built_in">string</span>, hashName&gt; m;</span><br><span class="line"></span><br><span class="line">m[<span class="built_in">std</span>::<span class="built_in">move</span>(p)] = <span class="string">"yeonon"</span>;</span><br><span class="line">m[<span class="built_in">std</span>::<span class="built_in">move</span>(p1)] = <span class="string">"yeonon1"</span>;</span><br><span class="line">m[<span class="built_in">std</span>::<span class="built_in">move</span>(p2)] = <span class="string">"yeonon3"</span>;</span><br><span class="line">m[<span class="built_in">std</span>::<span class="built_in">move</span>(p3)] = <span class="string">"yeonon4"</span>;</span><br></pre></td></tr></table></figure>

<p>key的类型声明成const Person&amp;&amp;，即右值引用。std::move则为对象产生一个右值引用。编译运行可验证，没有发生拷贝。是不是很简单？</p>
<p>好了，看了那么多，我想如果你不了解移动语义相关的知识，对上述内容一定会有很多疑惑，比如&amp;&amp;是个什么语法？std::move()又是干嘛的？为什么必须使用std::move()才行？…..接下来我将尽我所能介绍我所了解的知识。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>在介绍右值引用之前，先来看下什么是右值。C++里值的类别有两种，即左值和右值：</p>
<ul>
<li>左值：能被取地址且不能被移动的变量，例如堆上申请的变量</li>
<li>右值：不能被取地址，可以拥有变量名，例如函数里声明并返回的变量。也可以没有变量名，例如常数或者表达式的中间值</li>
</ul>
<p>左值和右值的区别还是有点模糊的，有的人会简单认为表达式左边的是左值，右边的是右值，这虽然在多数时候是对的，但从概念上来说，这是错误的。一种最简单的区分方法就是判断<strong>能不能取得其地址</strong>，这才是左值和右值的根本区别，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//a是左值，1是右值。因为我们能用&amp;a获得a的地址，但不能&amp;1获得1的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> b = bar(); <span class="comment">//b是左值，bar()的返回值是右值，这里我们并用不能&amp;bar()来获取内存地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = (bar() + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// (bar() + 1)是右值，即表达式中间值。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">int</span>* d = &amp;foo(); <span class="comment">//这里是正确的，因为foo返回类型是引用，必然不可能是右值。所以，这里foo()的返回值是左值，且在表达式右边。</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子中还可以发现，右值在表达式结束时就被废弃了，所以通常右值也含有“即将消亡”的意义。了解了左值和右值之后，就可以开始介绍右值引用了。</p>
<p>右值引用的语法是<code>&amp;&amp;</code>，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">1</span>; <span class="comment">//正确，1是右值，a是右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>; <span class="comment">//假设bar返回的值是栈上声明并初始化的</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = bar(); <span class="comment">//正确，bar返回值是右值，b是右值引用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; d = <span class="built_in">std</span>::<span class="built_in">move</span>(c); <span class="comment">//正确，虽然c是一个左值，但使用std::move()可以将左值转换成右值引用。</span></span><br></pre></td></tr></table></figure>

<p>在认识右值引用之后，可能有的朋友会产生一些疑惑，比如下面一个非常常见的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这里1是右值，a并不是右值引用。那这个语句合法吗？合法，因为这其实是“常引用”，常引用既可以接受左值，又可以接受右值。em..不过在这里只是扩展介绍，并不是本文的主要内容，所以不深入了。</p>
<p>在大概了解了右值引用之后，我们需要思考一下，为什么C++11会引入右值引用这个概念？他带来了什么好处呢？概括来说，引入右值引用的意义就是为了<strong>移动语义</strong>和所谓的<strong>完美转发</strong>（后面会介绍）。</p>
<p>C++11之前，一直存在一个问题：资源在需要移动的场景下，如何高效的完成移动？我们知道在以前移动一个资源，通常都需要至少一次拷贝操作，这在资源占用空间比较大的情况下，性能损耗影响会比较大。而移动语义和完美转发就可以解决这个问题，对一些特殊的资源（并不是所有资源）可以减少拷贝次数，甚至可以完全不需要拷贝（完美转发）。而理解移动语义和完美转发又必须要了解右值引用，所以才在这里花费了一些篇幅来介绍右值引用。</p>
<h2 id="移动语义和std-move"><a href="#移动语义和std-move" class="headerlink" title="移动语义和std::move"></a>移动语义和std::move</h2><p>C++的移动语义是一种概念上的东西，需要满足一定的条件才能触发，例如某个类想要触发移动语义就要实现移动构造函数，并且要结合右值引用使用。这么解释其实有点抽象，直接来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Resource(<span class="keyword">char</span>* data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            m_data[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            m_size = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(data) + <span class="number">1</span>];</span><br><span class="line">            m_size = <span class="built_in">std</span>::<span class="built_in">strlen</span>(data);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">strcpy</span>(m_data, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resouce::ctor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource(<span class="keyword">const</span> Resource&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size = other.m_size;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[m_size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::coyp-ctor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Resource&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        m_size = other.m_size;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[m_size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::coyp-assign"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource(Resource&amp;&amp; other)</span><br><span class="line">        :m_data(other.m_data)</span><br><span class="line">        ,m_size(other.m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.m_size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::move ctor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(Resource&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        m_size = other.m_size;</span><br><span class="line"></span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.m_size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::move assign"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Resource()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">r1</span><span class="params">(<span class="string">"1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Resource <span class="title">r2</span><span class="params">(r1)</span></span>; <span class="comment">//call ctor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Resource <span class="title">r3</span><span class="params">(<span class="string">"3"</span>)</span></span>;</span><br><span class="line">    r3 = r2;        <span class="comment">// call assign</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Resource <span class="title">r4</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(r1))</span></span>; <span class="comment">// call move ctor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Resource <span class="title">r5</span><span class="params">(<span class="string">"5"</span>)</span></span>;</span><br><span class="line">    r5 = <span class="built_in">std</span>::<span class="built_in">move</span>(r1); <span class="comment">//call move assign</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了演示，我把整个Resource类都贴上了</p>
</blockquote>
<p>上面的代码中，Resouce类有一个char*成员变量，这就是Resource类的资源。其中，大家可以很容易的发现Resource类的拷贝构造和赋值运算符重载，那Resource(Resource&amp;&amp; other)和Resource&amp; operator=(Resource&amp;&amp; other)是什么意思呢？</p>
<p>Resource(Resource&amp;&amp; other)是<strong>移动构造函数</strong>，他是为触发移动语义必须要实现的一个特殊构造函数，编译器不会为自定义类实现默认的移动构造函数。而Resource&amp; operator=(Resource&amp;&amp; other)是<strong>移动赋值运算符重载</strong>，如果向要在赋值的时候触发移动语义，也是必须要实现的，同样，编译器也不会为自定类实现默认的移动赋值运算符。</p>
<p>编译运行上面的代码，可以得到如下输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Resouce::ctor</span><br><span class="line">-----------------</span><br><span class="line">Resource::coyp-ctor</span><br><span class="line">-----------------</span><br><span class="line">Resouce::ctor</span><br><span class="line">Resource::coyp-assign</span><br><span class="line">-----------------</span><br><span class="line">Resource::move ctor</span><br><span class="line">-----------------</span><br><span class="line">Resouce::ctor</span><br><span class="line">Resource::move assign</span><br><span class="line">-----------------</span><br><span class="line">Resource::dtor</span><br><span class="line">Resource::dtor</span><br><span class="line">Resource::dtor</span><br><span class="line">Resource::dtor</span><br><span class="line">Resource::dtor</span><br></pre></td></tr></table></figure>

<p>Resource::move ctor对应代码第78行，Resource::move assign对应代码81行，即这两行代码触发了移动构造和移动赋值运算符（有兴趣的话，可以把这俩函数注释掉，看看打印的结果）。从两者的实现中，可以知道，这两个调用都没有发生拷贝。<strong>这就是移动语义带来的好处，节省了拷贝的开销。</strong></p>
<p>然后我们回过头来仔细看看移动拷贝和移动赋值运算符的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Resource(Resource&amp;&amp; other)</span><br><span class="line">    :m_data(other.m_data)</span><br><span class="line">    ,m_size(other.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    other.m_size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::move ctor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Resource&amp; <span class="keyword">operator</span>=(Resource&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = other.m_data;</span><br><span class="line">    m_size = other.m_size;</span><br><span class="line"></span><br><span class="line">    other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    other.m_size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource::move assign"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个函数的参数都是右值引用，那能不能是其他的呢？不行，为什么？看一下上述的实现，两者都会把other.m_data设置为nullptr，如果other是一个左值或者左值引用，且外部的代码在函数返回后继续使用other，会发生什么？在这里很简单，other,m_data是空指针，一般会发生nullptr error。而对于右值引用，回想一下右值引用的概念，右值引用是引用的是右值，而右值包含了“即将消亡”的意义，几乎可以表示后面不会有其他代码使用到这个右值了，所以右值可以安全移动的。</p>
<p>在了解上述知识后，我们再来看一个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Resource <span class="title">r</span><span class="params">(<span class="string">"1"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Resource r = getResource();</span><br></pre></td></tr></table></figure>

<p>上述代码会是怎样的输出？在认识移动语义之前，回答可能是会调用拷贝构造，但这在C++11中是不准确的。C++11后，这种情况会优先调用移动构造函数而不是拷贝构造函数，如果Resource类没有定义移动构造函数，编译器才会去调用拷贝构造函数。</p>
<blockquote>
<p>注意一下，上述代码最好先关闭copy elision的feature，否则你可能会发现既没有调用拷贝构造，也没有调用移动构造的情况。关闭copy elision可以使用如下编译选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -fno-elide-constructors -O0 move.cpp -o move</span><br></pre></td></tr></table></figure>


</blockquote>
<p>接下来我们来专门介绍下std::move。</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>上面介绍右值引用和移动语义的时候，都有使用过std::move。std::move的作用就是<strong>根据传入的参数返回一个对应类型的右值引用</strong>。所以其实我觉得叫做std::to_right_reference可能更能体现他的作用。下面是std::move的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">  <span class="built_in">move</span>(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现虽然短小，但内含很多信息，主要是3点：</p>
<ul>
<li><p>remove_reference，这个东西的作用是：如果模板参数的类型是一个引用类型（例如T&amp;或T&amp;&amp;），那就返回该引用对应的类型（例如T），如果不是引用，就直接返回本身类型。其内部实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span></span><br><span class="line"><span class="class">  &#123;</span> <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//左值引用版本，部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;_Tp&amp;&gt;</span></span><br><span class="line"><span class="class">  &#123;</span> <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//右值引用版本，部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;_Tp&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">  &#123;</span> <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br></pre></td></tr></table></figure>

<p>所以，其实他就是一个typedef。</p>
</li>
<li><p>move的参数类型_Tp&amp;&amp; __t，虽然是一个右值引用，但其实并不要求传递的参数必须是一个右值引用，这是因为“<strong>引用折叠</strong>”的特性，使得无论传入的参数是不是引用或者是哪种引用，都可以和形参匹配。关于引用折叠，稍后会介绍。</p>
</li>
<li><p>函数体，作用应该不用介绍了，主要看下用在这里的目的。std::remove_reference&lt;_Tp&gt;::type，即_Tp去掉引用的类型，这里假设Tp是一个引用T&amp;，那么std::remove_reference&lt;_Tp&gt;::type就是T，然后后面跟着&amp;&amp;，所以typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;其实就是T&amp;&amp;，即T的右值引用，之后通过static_case将__t的类型T&amp;转换成T&amp;&amp;，所以最终函数体返回值的类型是T&amp;&amp;，无论Tp是什么类型。</p>
</li>
</ul>
<p>我想经过上面的拆解，关于std::move，大家应该比较清晰了，那么就还剩一个“<strong>完美转发</strong>”了，不过在介绍完美转发之前，先说一下“引用折叠”这个特性。</p>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>引用折叠就是模板参数匹配遇到多个引用符号时，如何确定最终的引用类型的规则。有4种折叠的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; &amp; <span class="comment">//左值引用</span></span><br><span class="line">T&amp; &amp;&amp; <span class="comment">//右值引用</span></span><br><span class="line">T&amp;&amp; &amp; <span class="comment">//左值引用</span></span><br><span class="line">T&amp;&amp; &amp;&amp; <span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>

<p>例如上面的std::move的参数类型是_Tp&amp;&amp;, 那么如果模板实参是T&amp;的话，根据第二条引用折叠规则，则最终的类型会是_Tp&amp;，即仍然是左值引用，如果实参类型是_Tp&amp;&amp;，则最终类型是_Tp&amp;&amp;，即仍然是右值引用，如果类型是_Tp，，根据第三条条规则（编译器会将T推导成T&amp;之后再进行引用折叠），那么最终的类型将会是左值引用_Tp&amp;。</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp; t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo&amp; was called!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo&amp;&amp; was called!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warpper</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">warpper(bar());</span><br></pre></td></tr></table></figure>

<p>运行之后会是什么结果？答案是会打印“foo&amp; was called!”，这似乎不是这段代码的目的，wapper的目的应该只是作为一个装饰器，要保证在多层调用中调用路径不变。warpper(bar())语句调用的实参是bar()的返回值，是一个右值，目标应该是绑定到foo(T&amp;&amp; t)，但实际上却不是，为什么？</p>
<p>利用上面介绍的知识来拆解一下，首先bar()返回的是一个右值，由于wapper的形参是T&amp;&amp;，经过引用折叠后，t的最终类型是T&amp;&amp;，目前为止都符合预期。然后接下来调用foo(t)，此时由于在wapper函数内部，t不再是一个右值，而是一个左值，所以最终会调用左值引用版本的foo函数。那么如何解决呢？答案是利用std::forward()进行转发。</p>
<p>完美转发是利用引用折叠的特性实现的，最直接的使用完美转发特性的方式是使用std::forward, 其实现是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>std::foraward的作用是在转发的过程中保持参数类型不变，即如果传入的是左值，那么传递的过程中他依然是左值，传入的是右值，子阿传递过程中依然保持右值。那std::forawrd是如何保证的呢？</p>
<p>继续拆解std::forward，假设现在参数类型是int&amp;&amp;，首先std::remove_reference&lt;_Tp&gt;::type返回去掉引用的类型后得到int，与后面的&amp;组合后得到int&amp;，所以__t的类型是int&amp;，这里只是为了得到左值引用。关键在于static_cast，已知_Tp特化后的类型是int&amp;&amp;，展开后是int&amp;&amp; &amp;&amp;，经过引用折叠后即得到int&amp;&amp;，即仍然是右值引用。（同样的方式可以带入左值引用看看）</p>
<p>那么要解决上面warpper的问题，只需要把调用foo()的地方改一下就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warpper</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(<span class="built_in">std</span>::forward&lt;t&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后发现会打印foo&amp;&amp; was called!，即符合预期。这就是完美转发的含义和作用！</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文主要介绍了右值引用，移动语义，引用折叠，完美转发等相关知识点。</p>
<p>移动语义可以解决资源转移时拷贝资源带来的性能消耗问题，使用场景非常广泛，使用得当（只转移确定后续不再使用的资源）可以对代码性能有不小的提升。</p>
<p>完美转发则大多数用在模板编程中，是为了解决在模板编程中如果存在参数转发的情况，可能会导致调用路径不符合预期等异常的问题。</p>
<p>而右值引用和引用折叠则作为语言特性支撑实现移动语义和完美转发。</p>
<blockquote>
<p>可能会有朋友有疑问，好像完美转发和移动语义没有什么关系啊？em…确实是没有直接的联系，他们的共同点都是直接利用了右值引用和引用折叠这两个语言特性，所以我都放在一篇文章里介绍了。</p>
</blockquote>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><ul>
<li><input disabled="" type="checkbox"> auto and decltype</li>
<li><input checked="" disabled="" type="checkbox"> defaulted and deleted functions</li>
<li><input checked="" disabled="" type="checkbox"> final and override</li>
<li><input disabled="" type="checkbox"> trailing return type</li>
<li><input checked="" disabled="" type="checkbox"> rvalue references</li>
<li><input checked="" disabled="" type="checkbox"> move constructors and move assignment operators</li>
<li><input disabled="" type="checkbox"> scoped enums</li>
<li><input checked="" disabled="" type="checkbox"> constexpr and literal types</li>
<li><input disabled="" type="checkbox"> list initialization</li>
<li><input disabled="" type="checkbox"> delegating and inherited constructors</li>
<li><input disabled="" type="checkbox"> brace-or-equal initializers</li>
<li><input checked="" disabled="" type="checkbox"> nullptr</li>
<li><input checked="" disabled="" type="checkbox"> long long</li>
<li><input checked="" disabled="" type="checkbox"> char16_t and char32_t</li>
<li><input disabled="" type="checkbox"> type aliases</li>
<li><input disabled="" type="checkbox"> variadic templates</li>
<li><input disabled="" type="checkbox"> generalized (non-trivial) unions</li>
<li><input disabled="" type="checkbox"> generalized PODs (trivial types and standard-layout types)</li>
<li><input disabled="" type="checkbox"> Unicode string literals</li>
<li><input disabled="" type="checkbox"> user-defined literals</li>
<li><input disabled="" type="checkbox"> attributes</li>
<li><input disabled="" type="checkbox"> lambda expressions</li>
<li><input checked="" disabled="" type="checkbox"> noexcept specifier and noexcept operator</li>
<li><input checked="" disabled="" type="checkbox"> alignof and alignas</li>
<li><input disabled="" type="checkbox"> multithreaded memory model</li>
<li><input disabled="" type="checkbox"> thread-local storage</li>
<li><input disabled="" type="checkbox"> GC interface</li>
<li><input disabled="" type="checkbox"> range-for (based on a Boost library)</li>
<li><input disabled="" type="checkbox"> static_assert (based on a Boost library)</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>