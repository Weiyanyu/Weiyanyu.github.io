<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Yeonon&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            C++新特性梳理系列：C++11 智能指针
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C/C++ 里指针是非常常见的，既是强大的武器，也是难以使用的，如果使用不当，可能会造成极其诡异且难以排查的问题，例如内存泄露，野指针，踩内存等，而空指针异常算是相对比较好排查的了。在C++中，一些场景已经使用“引用”来替代了，例如函数传递参数时防止无效的拷贝，或者出于某些目的，要在函数内部改变参数的值的场景，使用引用将会比指针更简单，也更安全。而C++11更进一步，引入了”智能指针”，可以在更多场景来替代裸指针，进而降低由于使用裸指针带来的风险。在真正开始介绍智能指针之前，先梳理一下普通指针（裸指针）存在的问题，这样才能更好的理解智能指针。</p>
<h3 id="普通指针存在的问题"><a href="#普通指针存在的问题" class="headerlink" title="普通指针存在的问题"></a>普通指针存在的问题</h3><p>普通指针最明显，也是最容易想到的问题就是内存泄露，如果从堆中申请了一块内存，而忘记或者由于程序流程问题导致没有释放内存，则会发生内存泄露，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里p没有使用delete来释放内存，除非进程结束，否则会一直都一块内存没有得到释放，甚至函数执行多次，最终没有可用内存，进程发生OOM异常。</p>
<blockquote>
<p>这里提一嘴，虽然只有new，没有delete都是内存泄露，但不一定真的是问题，因为有的对象的声明周期就是和进程的生命周期一样（例如单例），他们的内存释放并不需要特别关心，随着进程释放即可。</p>
</blockquote>
<p>普通指针还有一个常见的问题就是“野指针”和“空悬指针”。野指针就是没有初始化的指针，使用野指针是未定义的。空悬指针就是这个指针既不是null，也不指向任何有效内存，使用空悬指针也是未定义的。</p>
<p>导致野指针的原因有3种：</p>
<ol>
<li>指针没有初始化。默认不会初始化为NULL，而会是一个随机的值。</li>
<li>指针被delete/free之后没有置为NULL。</li>
<li>指针操作超过了作用域。例如指向栈上对象的指针，出栈了，该对象内存已经被释放了。</li>
</ol>
<p>导致出现空悬指针的原因是很多，主要的特点就是该指针无法再释放原先指向的内存，所以被称作“空悬”。</p>
<p>下面是一些例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(<span class="keyword">int</span>* pc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    pc = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//野指针 1</span></span><br><span class="line">    <span class="keyword">int</span> *pa;</span><br><span class="line">    *pa = <span class="number">1</span>;            <span class="comment">//core dump</span></span><br><span class="line">    <span class="comment">//野指针 2</span></span><br><span class="line">    <span class="keyword">int</span> *pb = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    *pb = <span class="number">2</span>;            <span class="comment">//core dump</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//野指针 3</span></span><br><span class="line">    <span class="keyword">int</span> *pc;</span><br><span class="line">    doProcess(pc);</span><br><span class="line">    *pc = <span class="number">3</span>;            <span class="comment">//core dump</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空悬指针 pd</span></span><br><span class="line">    <span class="keyword">int</span>* pd = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span>* pe = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *pd = <span class="number">4</span>;</span><br><span class="line">    *pe = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    pd = pe;  <span class="comment">//注意这里赋值后，pd原先所指向的内存已经找不回来了，几乎肯定会发生内存泄露</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pe;</span><br><span class="line">    <span class="keyword">delete</span> pd;  <span class="comment">//这里会double-free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解普通指针存在的问题后，接下来开始正式介绍智能指针，看下智能指针是否解决上面的这些问题。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>所谓的智能指针，简单来说就是用对象包裹裸指针，该对象会在析构的时候决定是否要释放该裸指针指向的内存，不同的智能指针，策略会有所不同，相同的就是用户不再需要关心内存的释放。C++11新增了3个智能指针，分别是：</p>
<ul>
<li>shared_ptr，即具有共享的概念。可以被拷贝，多个shared_ptr可以指向同一块内存，内存释放策略是当最后一个shared_ptr析构的时候释放所指向的内存。</li>
<li>unique_ptr，即唯一的，不可以被拷贝，如果发生拷贝操作，则会编译报错。相比shared_ptr，用户可以很明确的知道内存释放的时机。</li>
<li>weak_ptr，这个比较特殊，并不和裸指针关联，后面再详细介绍吧。</li>
</ul>
<blockquote>
<p>其实还有一个auto_ptr，但C++11之后废弃了，各位有兴趣可以去网上看下相关内容。</p>
</blockquote>
<p>接下来一一介绍这3个智能指针。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr可以被拷贝，每次拷贝都会将引用计数加1，shared_ptr对象的析构则会将引用计数减1，直到引用计数为0才会释放内存。其声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">class</span> <span class="title">shared_ptr</span>;</span></span><br></pre></td></tr></table></figure>

<p>使用也很简单，有两种创建方式，一是通过构造函数，二是通过make_shared创建。网上流传的说法是make_shared效率更高，因为少了一次内存申请的操作（详细可以看下这篇文章<a href="https://www.cnblogs.com/leijiangtao/p/12046333.html" target="_blank" rel="noopener">C++11使用make_shared的优势和劣势</a>。下面是一个使用的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过构造函数创建</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Resource(<span class="number">1</span>,<span class="number">1.1</span>))</span></span>;</span><br><span class="line"><span class="comment">//通过make_shared创建</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; sp2 = make_shared&lt;Resource&gt;(<span class="number">2</span>,<span class="number">2.2</span>);</span><br><span class="line"><span class="comment">//这里应该输出1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 usecount = "</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; sp3 = sp1;</span><br><span class="line"><span class="comment">//这里发生了1次拷贝，应该输出2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 usecount = "</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//这里又发生了一次拷贝，应该输出3，并且由于sp2指向改变了，所以原先的sp2引用计数已经为0，所以会释放Resource::2,2.2这个对象，主要看输出</span></span><br><span class="line">sp2 = sp1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 usecount = "</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用了use_count接口，可以打印出当前的引用计数，是一个调试的手段。shared_ptr还有其他有用的接口，各位可以去看下文档。</p>
<h4 id="shared-prt的问题"><a href="#shared-prt的问题" class="headerlink" title="shared_prt的问题"></a>shared_prt的问题</h4><p>虽然使用shared_ptr可以规避裸指针带来的问题，但也不是100%安全的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过get来过去裸指针</span></span><br><span class="line">Resource* r1 = sp1.<span class="built_in">get</span>();</span><br><span class="line"><span class="comment">//delete手动释放资源</span></span><br><span class="line"><span class="keyword">delete</span> r1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的输出会是未初始化的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 resource value : "</span> &lt;&lt; sp1-&gt;getI() &lt;&lt; <span class="string">" "</span> &lt;&lt; sp1-&gt;getD() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//最后当sp1离开作用域的时候会发生一次double free异常</span></span><br></pre></td></tr></table></figure>

<p>这里通过get获取裸指针并手动释放了内存，当sp1离开作用域的时候引用计数为0，会再一次释放内存，这样就造成了double free，所以除非需要兼容老代码的场景，get接口还是尽量不要使用。</p>
<p>因为计数器的原因，shared_prt还存在循环引用的问题，即sp1封装的资源是sp2，而sp2封装的资源是sp1这种场景，实际的资源内存是不会被释放的，因为两者引用计数在出作用域后还一直是1，且无法再减少了，如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    :mPrt(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMprt</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; prt)</span> </span>&#123; mPrt = prt; &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; mPrt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()</span><br><span class="line">    :mPrt(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMprt</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; prt)</span> </span>&#123; mPrt = prt; &#125;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; mPrt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line"></span><br><span class="line">sp1-&gt;setMprt(sp2);</span><br><span class="line">sp2-&gt;setMprt(sp1);</span><br></pre></td></tr></table></figure>

<p>要解决循环引用的问题，一种是从业务逻辑上去考虑，这种场景是否真的有必要？一种是使用后面提到的weak_ptr，介绍到的时候我会再次提到循环引用的问题。这里先继续看shared_ptr的另一个问题。</p>
<p>考虑这样一个场景，我们的某个类需要提供一个函数返回this指针或者将this指针传递给外部函数（例如回调函数），例如这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        :m_name(name),</span><br><span class="line">         m_callback(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~Book()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Book*)&gt; callback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里也可以直接传递this，无所谓，对本例要说的问题无影响</span></span><br><span class="line">        m_callback(getPtr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Book* <span class="title">getPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Book*)&gt; m_callback;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bookCallback</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"book name: "</span> &lt;&lt; book-&gt;getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">book</span><span class="params">(<span class="string">"C++ prime"</span>)</span></span>;</span><br><span class="line">    book.setCallback(bookCallback);</span><br><span class="line">    book.doProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Book有一个callback函数，这个callback函数需要一个Book*的参数，调用doProcess的时候会触发bookCallback，并把this传递到bookCallback函数里。如果现在学了shared_prt，不想再使用裸指针了，所以要优化一下代码，用shared_prt代替裸指针：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Cppnew/smart.cpp b/Cppnew/smart.cpp</span><br><span class="line">index 79839e4..3e633fe 100644</span><br><span class="line"><span class="comment">--- a/Cppnew/smart.cpp</span></span><br><span class="line"><span class="comment">+++ b/Cppnew/smart.cpp</span></span><br><span class="line">@@ -127,14 +127,15 @@ public:</span><br><span class="line">         std::cout &lt;&lt; "Book::dtor" &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    void setCallback(std::function&lt;void(Book*)&gt; callback) </span></span><br><span class="line"><span class="addition">+    void setCallback(std::function&lt;void(std::shared_ptr&lt;Book&gt;)&gt; callback) </span></span><br><span class="line">     &#123;</span><br><span class="line">         m_callback = callback;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     void doProcess()</span><br><span class="line">     &#123;</span><br><span class="line"><span class="deletion">-        m_callback(getPtr());</span></span><br><span class="line"><span class="addition">+        std::shared_ptr&lt;Book&gt; local_sp(this);</span></span><br><span class="line"><span class="addition">+        m_callback(local_sp);</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     Book* getPtr()</span><br><span class="line">@@ -145,10 +146,10 @@ public:</span><br><span class="line">     const std::string getName() &#123; return m_name; &#125;</span><br><span class="line"> private:</span><br><span class="line">     std::string m_name;</span><br><span class="line"><span class="deletion">-    std::function&lt;void(Book*)&gt; m_callback;   </span></span><br><span class="line"><span class="addition">+    std::function&lt;void(std::shared_ptr&lt;Book&gt;)&gt; m_callback;   </span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-void bookCallback(Book* book)</span></span><br><span class="line"><span class="addition">+void bookCallback(std::shared_ptr&lt;Book&gt; book)</span></span><br><span class="line"> &#123;</span><br><span class="line">     std::cout &lt;&lt; "book name: " &lt;&lt; book-&gt;getName() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意，doProcess里创建了一个shared_prt，用来管理this，然后再传递给callback函数。好像成功了，实际运行呢？会发生core dump，为什么？因为创建shared_prt后，引用计数为1，然后传递给callback的时候发生拷贝，引用计数为2，callback完成后，引用计数再次为1，目前为止都不会有什么问题，那么doProcess执行完毕呢？local_sp发生析构，然后引用计数为0，之后就释放this指针指向的内存！这就很危险了，这意味着，后面如果继续使用book对象，将会是未定义的！那如何解决这个问题呢？可以让Book类继承enable_shared_from_this，并使用shared_from_this接口来解决，如下是修改：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-class Book</span></span><br><span class="line"><span class="addition">+class Book : public std::enable_shared_from_this&lt;Book&gt;</span></span><br><span class="line"></span><br><span class="line">     void doProcess()</span><br><span class="line">     &#123;</span><br><span class="line"><span class="deletion">-        m_callback(getPtr());</span></span><br><span class="line"><span class="addition">+        std::shared_ptr&lt;Book&gt; local_sp = shared_from_this();</span></span><br><span class="line"><span class="addition">+        m_callback(local_sp);</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-    Book book("C++ prime");</span></span><br><span class="line"><span class="deletion">-    book.setCallback(bookCallback);</span></span><br><span class="line"><span class="deletion">-    book.doProcess();</span></span><br><span class="line"><span class="addition">+    std::shared_ptr&lt;Book&gt; book = make_shared&lt;Book&gt;("C++ prime");</span></span><br><span class="line"><span class="addition">+    book-&gt;setCallback(bookCallback);</span></span><br><span class="line"><span class="addition">+    book-&gt;doProcess();</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于enable_shared_from_this的实现是利用了weak_prt，所以main函数里不能再使用栈上创建对象的方式了，并且一定要是公有继承的方式！</p>
<p>除了上面提到的问题之外，还有一个对于数组的释放问题。数组的释放应该要使用关键字delete[]，当shared_prt默认只会使用delete,这时候就需要用户自定义删除器来解决了，也很简单，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function"><span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Book[<span class="number">5</span>], </span></span></span><br><span class="line"><span class="function"><span class="params">        [ ](Book* p) &#123; <span class="keyword">delete</span>[ ] p; &#125; )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为shared_prt是最常用的智能指针，所以就说了比较多，希望各位没有看困，接下来的unique_ptr和weak_ptr我会尽量说的简单一些，主要是抛砖引玉。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_prt包含独占的含义，所以unique_prt不能被拷贝，但可以移动。且声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Deleter</span> = <span class="title">std</span>:</span>:default_delete&lt;T&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Deleter</span></span></span><br><span class="line"><span class="class">&gt; <span class="title">class</span> <span class="title">unique_ptr</span>&lt;T[], Deleter&gt;;</span></span><br></pre></td></tr></table></figure>

<p>unique_ptr对待数组有些不一样，unique_ptr封装数组资源的时候，使用方式是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int[ ]&gt; up( new int[5] );</span><br></pre></td></tr></table></figure>

<p>如果对unique_ptr，将会编译报错，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up2</span><span class="params">(up1)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2 = up1;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">smart.cpp:160:33: error: use of deleted <span class="keyword">function</span> ‘std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]’</span><br><span class="line">  160 |     std::unique_ptr&lt;int&gt; up2(up1);</span><br><span class="line">      |                                 ^</span><br><span class="line">In file included from /usr/include/c++/9/memory:80,</span><br><span class="line">                 from smart.cpp:2:</span><br><span class="line">/usr/include/c++/9/bits/unique_ptr.h:414:7: note: declared here</span><br><span class="line">  414 |       unique_ptr(const unique_ptr&amp;) = delete;</span><br><span class="line">      |       ^~~~~~~~~~</span><br><span class="line">smart.cpp:161:26: error: redeclaration of ‘std::unique_ptr&lt;int&gt; up2’</span><br><span class="line">  161 |     std::unique_ptr&lt;int&gt; up2 = up1;</span><br><span class="line">      |                          ^~~</span><br><span class="line">smart.cpp:160:26: note: ‘std::unique_ptr&lt;int&gt; up2’ previously declared here</span><br><span class="line">  160 |     std::unique_ptr&lt;int&gt; up2(up1);</span><br><span class="line">      |</span><br></pre></td></tr></table></figure>

<p>但移动是可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2 = <span class="built_in">std</span>::<span class="built_in">move</span>(up1);</span><br></pre></td></tr></table></figure>

<p>移动后，原来的up1就不能再使用了（准确的说再使用就是未定义的）。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr和shared_ptr是强相关的，weak_ptr只能根据shared_ptr构造，其本身并不拥有资源，所以无法直接通过weak_ptr去操作资源，他和关联的shared_prt共享计数器指针。weak_ptr还增加了弱引用计数的概念，相对的，shared_prt的引用计数就是强引用计数，弱引用计数不会对内存释放的策略产生影响。当weak_ptr发生拷贝的时候，弱引用计数会加1，强引用计数不会改变。</p>
<p>weak_ptr的创建比较简单，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面有提到，弱引用计数不会影响释放策略，那如果weak_ptr关联的shared_ptr引用计数为0了，资源内存被释放了，weak_ptr会发生什么呢？weak_ptr的状态就变成所谓的过期，所以为了防止使用无效的资源，weak_ptr提供了expired和use_count接口判断shared_ptr是否有效。weak_ptr还提供了lock接口将weak_ptr提升为shared_prt，同时将对应的强引用计数加1。</p>
<p>上面有提到，使用weak_ptr可以解决循环引用的问题，现在来看一下是如何解决的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMprt</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;B&gt; prt)</span> </span>&#123; mPrt = prt; &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;B&gt; mPrt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMprt</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;A&gt; prt)</span> </span>&#123; mPrt = prt; &#125;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::dtor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;A&gt; mPrt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//相对之前的代码，将shared_prt改称了weak_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">spa</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">spb</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line"></span><br><span class="line">    spa-&gt;setMprt(spb);</span><br><span class="line">    spb-&gt;setMprt(spa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出可以看到A和B都调用了dtor，说明资源已经被释放了，这也说明了weak_ptr确实是可以解决循环引用问题的。我们拆解一下这中间发生了什么，就可以理解了。</p>
<ol>
<li>首先创建了两个shared_prt，此时两者引用计数都为1。</li>
<li>之后setMptr赋值，由于set的是weak_ptr，所以强引用计数没有变，弱引用计数为1。</li>
<li>最后离开作用域，两个shared_prt的强引用计数都减1，此时检测到强引用计数为0了，所以就去释放内存。</li>
</ol>
<p>细心观察，可以发现利用weak_prt解决问题的关键就是weak_prt的拷贝不会导致强引用计数增加，进而顺利释放内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了三大智能指针，shared_prt，weak_ptr，unique_ptr。其中着重介绍了shared_ptr，因为这是最常被使用的的一种智能指针。shared_ptr虽然好用，但也有一些问题，例如循环引用以及将this指针传递给外部并且想用shared_ptr封装的场景的坑等等。unique_ptr用得比较少，但如果场景合适，应该优先使用unique_ptr，可以防止拷贝。weak_ptr可以解决循环引用的问题，在合适的场景也是优先使用。</p>
<p>智能指针目标是替代裸指针，使得内存管理更加简单和安全，所以推荐多使用智能指针。至于使用哪种类型的智能指证，则完全取决于实际业务，如果某个资源明确就是要独占的，那么用unique_ptr会比较好，如果想要在多个对象之间共享资源，那shared_prt是唯一的选择。而weak_ptr主要就是为了解决循环引用的，在可能存在循环引用的场景可以使用weak_prt，但使用起来可以会没那么方便，因为weak_ptr要想访问资源，需要先提升为shared_ptr才行。</p>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">atomic operations library</a></li>
<li><input checked="" disabled="" type="checkbox"> smart pointer</li>
<li><input disabled="" type="checkbox"> <code>emplace()</code> and other use of rvalue references throughout all parts of the existing library<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener">std::unique_ptr</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/move_iterator" target="_blank" rel="noopener">std::move_iterator</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">std::initializer_list</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Stateful_and_stateless_allocators" target="_blank" rel="noopener">stateful</a> and <a href="https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor" target="_blank" rel="noopener">scoped</a> allocators</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/container/forward_list" target="_blank" rel="noopener">std::forward_list</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/chrono" target="_blank" rel="noopener">chrono library</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/numeric/ratio" target="_blank" rel="noopener">ratio library</a></li>
<li><input disabled="" type="checkbox"> new <a href="https://en.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">algorithms</a>:<ul>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::all_of</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::any_of</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::none_of</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/find" target="_blank" rel="noopener">std::find_if_not</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/copy_n" target="_blank" rel="noopener">std::copy_n</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/move" target="_blank" rel="noopener">std::move</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/move_backward" target="_blank" rel="noopener">std::move_backward</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle" target="_blank" rel="noopener">std::random_shuffle</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle" target="_blank" rel="noopener">std::shuffle</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned" target="_blank" rel="noopener">std::is_partitioned</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/partition_copy" target="_blank" rel="noopener">std::partition_copy</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/partition_point" target="_blank" rel="noopener">std::partition_point</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted" target="_blank" rel="noopener">std::is_sorted</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted_until" target="_blank" rel="noopener">std::is_sorted_until</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_heap" target="_blank" rel="noopener">std::is_heap</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/is_heap_until" target="_blank" rel="noopener">std::is_heap_until</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/minmax" target="_blank" rel="noopener">std::minmax</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/minmax_element" target="_blank" rel="noopener">std::minmax_element</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_permutation" target="_blank" rel="noopener">std::is_permutation</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/iota" target="_blank" rel="noopener">std::iota</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy_n" target="_blank" rel="noopener">std::uninitialized_copy_n</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/locale#Locale-independent_unicode_conversion_facets" target="_blank" rel="noopener">Unicode conversion facets</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">thread library</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/utility/functional/function" target="_blank" rel="noopener">std::function</a></li>
<li><input checked="" disabled="" type="checkbox"> std::bind</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/error/exception_ptr" target="_blank" rel="noopener">std::exception_ptr</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/error/error_code" target="_blank" rel="noopener">std::error_code</a> and <a href="https://en.cppreference.com/w/cpp/error/error_condition" target="_blank" rel="noopener">std::error_condition</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">iterator</a> improvements:<ul>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/begin" target="_blank" rel="noopener">std::begin</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/end" target="_blank" rel="noopener">std::end</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/next" target="_blank" rel="noopener">std::next</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/prev" target="_blank" rel="noopener">std::prev</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Unicode conversion functions</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>