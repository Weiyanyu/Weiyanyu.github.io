<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Yeonon&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Linux C++ 网络编程(二): io多路复用
        </p>
        <hr>
    </div>
    <div class="post-content">
        <blockquote>
<p>本文所有代码均可以在我的Github上找到，地址：<a href="https://github.com/Weiyanyu/budd/tree/master/test" target="_blank" rel="noopener">https://github.com/Weiyanyu/budd/tree/master/test</a></p>
</blockquote>
<h3 id="1-理解IO多路复用"><a href="#1-理解IO多路复用" class="headerlink" title="1. 理解IO多路复用"></a>1. 理解IO多路复用</h3><blockquote>
<p>关于IO多路复用的概念和介绍，网上有很多优秀的资料。本文只是简单谈谈我个人对IO多路复用的理解，更专业，详细的知识建议参考《UNIX 网络编程》。</p>
</blockquote>
<p>要理解IO多路复用，私以为首先需要解决3个问题：</p>
<ul>
<li>什么是IO多路复用？</li>
<li>为什么需要IO多路复用？</li>
<li>IO多路复用技术可以带来那些增益？又有哪些不足？</li>
</ul>
<h4 id="1-1-什么是IO多路复用"><a href="#1-1-什么是IO多路复用" class="headerlink" title="1.1 什么是IO多路复用"></a>1.1 什么是IO多路复用</h4><p>在给出IO多路复用的定义之前，我们先提出3个问题：</p>
<ul>
<li>多路是什么意思？</li>
<li>复用又是什么意思？复用什么东西？</li>
</ul>
<p>在Linux下， 多路指的多个文件描述符，在网络编程中，可以从更高的抽象层次理解为多个网络连接，因为Linux中的每一个网络连接都对应一个文件描述符（下文简称fd）。</p>
<p>复用值的是复用某个执行单元，可以是进程（单进程程序），也可以是线程（多线程程序），这取决于程序的架构设计。</p>
<p>将两者结合在一起就是：多个网络连接使用同一个进程或者线程来执行读写操作。</p>
<p>这个定义有些粗糙了，下面是更加详细一些的定义：</p>
<p>IO多路复用是一种同步IO模型，实现一个进程或者线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞进程或者线程，交出cpu。</p>
<h4 id="1-2-为什么需要IO多路复用"><a href="#1-2-为什么需要IO多路复用" class="headerlink" title="1.2 为什么需要IO多路复用"></a>1.2 为什么需要IO多路复用</h4><p>同步IO模型有两种：</p>
<ul>
<li>同步阻塞</li>
<li>同步非阻塞</li>
</ul>
<p>同步阻塞模型很容易理解。以read操作为例，当线程调用read时，内核会先从磁盘读取数据到内核空间，再从内核空间拷贝到用户空间返回给用户。在同步阻塞模型下，这整个过程线程都不能干其他事情，即阻塞的含义。（本系列文章第一篇文章就是同步阻塞模型的应用）</p>
<p>而同步非阻塞模型相比于同步阻塞模型来说，则不需要等待上述拷贝数据的整个过程，用户在第一次调用read的时候，如果数据没有准备好（数据可能是准备好的），那么read调用就会返回一个error标志，告知程序此时数据没有准备好，程序可以理解返回去作其他事情，这就是非阻塞。之后程序可能会多次轮询，如果数据准备好了，就会返回对应的数据。使用同步非阻塞模型的一个特点是需要多次轮询，会有一些CPU消耗，但不会阻塞线程，程序的整体吞吐量要由于阻塞模型。</p>
<blockquote>
<p>关于上述两种模型的更详细介绍可以参考<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html</a>.</p>
</blockquote>
<p>同步阻塞模型下，IO读写操作会阻塞线程，所以程序无法在处理读写操作的时候接受新的读写操作请求。对应到网络编程中，就是线程在处理数据的读写过程中无法接受新的连接。非阻塞模型在这点上会优于阻塞模型，但如上所说，存在CPU轮询的代价。</p>
<p>所以，为了进一步提升性能，我们需要一种非阻塞的，又不需要重复去询问内核数据是否准备好的机制。IO多路复用可以解决这个问题，IO多路复用基于事件，把读完成，可写等IO操作抽象为一个“事件”，当有事件发生的时候，内核会主动通知用户程序来执行相应的IO操作，不需要用户程序主动去询问内核，而没有事件发生的时候，线程可以继续作其他事情。相比于同步非阻塞模型，少了轮询的步骤。</p>
<h4 id="1-3-IO多路复用技术可以带来那些增益？又有哪些不足？"><a href="#1-3-IO多路复用技术可以带来那些增益？又有哪些不足？" class="headerlink" title="1.3 IO多路复用技术可以带来那些增益？又有哪些不足？"></a>1.3 IO多路复用技术可以带来那些增益？又有哪些不足？</h4><p>IO多路复用的增益在上面1.2已经有过讨论，其不足主要是：</p>
<ul>
<li>IO多路复用依然是同步IO模型，在一些特殊的场景下，吞吐量上还是比异步IO差一些。</li>
<li>IO多路复用的编程复杂度要高于简单的同步阻塞和同步非阻塞模型。所幸Linux内核提供了select,poll,epoll等系统调用来帮助开发者来运用IO多路复用。</li>
</ul>
<h3 id="2-Linux-IO多路复用系统调用select-poll和epoll"><a href="#2-Linux-IO多路复用系统调用select-poll和epoll" class="headerlink" title="2. Linux IO多路复用系统调用select, poll和epoll"></a>2. Linux IO多路复用系统调用select, poll和epoll</h3><h4 id="2-1-select"><a href="#2-1-select" class="headerlink" title="2.1 select"></a>2.1 select</h4><p>select是最早的IO多路复用实现，下面是select的API描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. nfds参数是select需要监听的fd中“值”最大的那个fd+1，和监听的fd数量没有关系，例如现在监听1，18，20三个fd，那么nfds的值就是20 + 1 = 21</span></span><br><span class="line"><span class="comment">//2. readfds即监听读事件的fd列表，类型是fd_set结构体</span></span><br><span class="line"><span class="comment">//3. writefds监听写事件的fd列表</span></span><br><span class="line"><span class="comment">//4. exceptfds即异常fd列表</span></span><br><span class="line"><span class="comment">//5. 超时事件，类型是通用的timeval</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select调用需要指定需要监听的读写事件的fd列表，其调用返回的时候（有事件发生）会往readfds，writefds，exceptfds里面写值（把对应的fd置位），用户程序可以通过判断某个fd是否被置位来判断该fd对应的事件是否发生。所以，使用select调用的用户程序还需要在select返回之后遍历fds，而且这个fds的size并不是监听的fd的数量，而是nfds值，这也是select的局限性之一。另一个局限是可监听的fd数量有上限，上限值是FD_SETSIZE，这个可以通过修改宏定义来修改，linux新版本内核中这个值已经很大了。（很多文章说是1024，那是老版本的内核）</p>
<p>下面是select的一个简单使用示例(echo服务):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processConn</span><span class="params">(<span class="keyword">int</span> connFd, struct in_addr clientAddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error socket!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="number">8080</span>;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenFd, (<span class="keyword">const</span> struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bind server error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenFd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"listen error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    fd_set writefds;</span><br><span class="line">    <span class="comment">//初始化fd_set</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_ZERO(&amp;writefds);</span><br><span class="line">    <span class="comment">//置为listenFd</span></span><br><span class="line">    FD_SET(listenFd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">    fd_set tempReadfds;</span><br><span class="line">    fd_set tempWritefds;</span><br><span class="line">    <span class="keyword">int</span> maxFd = listenFd;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffers[<span class="number">1024</span>][BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//在循环中使用select必须要重新初始化fd_set</span></span><br><span class="line">        <span class="comment">//reinit</span></span><br><span class="line">        tempReadfds = readfds;</span><br><span class="line">        tempWritefds = writefds;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> addrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> eventNum = select(maxFd+<span class="number">1</span>, &amp;tempReadfds, &amp;tempWritefds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">//判断listenFd在readfds中是否被置位,即判断是否有读事件</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenFd, &amp;tempReadfds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> connFd = accept(listenFd, (struct sockaddr *)&amp;clientAddr, &amp;addrLen);</span><br><span class="line">            <span class="keyword">if</span> (connFd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"accept error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> clientIP[INET_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">memset</span>(clientIP, <span class="number">0</span>, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line"></span><br><span class="line">            inet_ntop(AF_INET, &amp;clientAddr, clientIP, INET_ADDRSTRLEN);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"accept client ip : "</span> &lt;&lt; clientIP &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            FD_SET(connFd, &amp;readfds);</span><br><span class="line">            maxFd = connFd &gt; maxFd ? connFd : maxFd;</span><br><span class="line">            <span class="keyword">if</span> (--eventNum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//no need wait other </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fd = <span class="number">0</span>; fd &lt;= maxFd; fd++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd == listenFd) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//判断listenFd在writefds中是否被置位，即判断是否有写事件</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;tempReadfds)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">memset</span>(buffers[fd], <span class="number">0</span>, <span class="keyword">sizeof</span>(buffers[fd]));</span><br><span class="line">                <span class="keyword">int</span> len = recv(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//if len equal 0, mean client disconnect, we must add this condition, or else it will cause server crash</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"client force close connection!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                    FD_CLR(fd, &amp;readfds);</span><br><span class="line">                    <span class="keyword">if</span> (maxFd == fd) &#123;</span><br><span class="line">                        maxFd--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                FD_SET(fd, &amp;writefds);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fd, &amp;tempWritefds)) &#123;</span><br><span class="line">                send(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                FD_CLR(fd, &amp;writefds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-poll"><a href="#2-2-poll" class="headerlink" title="2.2 poll"></a>2.2 poll</h4><p>poll API描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. fds, 即监听的fd列表，元素是pollfd，一般传入数组，调用结果会设置到pollfd结构体的revents参数里</span></span><br><span class="line"><span class="comment">//2. nfds, 表示监听的fd的数量,注意和select的区别</span></span><br><span class="line"><span class="comment">//3. 超时时间，单位是毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;			<span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    short <span class="keyword">int</span> events;		<span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    short <span class="keyword">int</span> revents;		<span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>poll与select最大的不同是没有最大fd size的限制，可以监听任意数量的fd（当然是要小于系统的fd数量，且fd过多后性能会下降）。同select一样的地方是依然需要在poll调用返回后遍历fd来检查fd是否被置位。但只需要遍历监听的fd set数量即可。</p>
<p>下面是一个示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processConn</span><span class="params">(<span class="keyword">int</span> connFd, struct in_addr clientAddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error socket!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="number">8080</span>;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenFd, (<span class="keyword">const</span> struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bind server error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenFd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"listen error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义pollfds数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfds</span>[1024];</span></span><br><span class="line">    pollfds[<span class="number">0</span>].fd = listenFd;</span><br><span class="line">    <span class="comment">//设置监听的事件类型，这里是读</span></span><br><span class="line">    pollfds[<span class="number">0</span>].events |= (POLLIN | POLLPRI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        pollfds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffers[<span class="number">1024</span>][BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> addrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eventNum = poll(pollfds, maxNum, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxNum; i++) &#123;</span><br><span class="line">            <span class="comment">//检查是否是读事件</span></span><br><span class="line">            <span class="keyword">if</span> (pollfds[i].revents &amp; (POLLIN | POLLPRI)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pollfds[i].fd == listenFd) &#123;</span><br><span class="line">                    <span class="keyword">int</span> connFd = accept(listenFd, (struct sockaddr *)&amp;clientAddr, &amp;addrLen);</span><br><span class="line">                    <span class="keyword">if</span> (connFd == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"accept error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">char</span> clientIP[INET_ADDRSTRLEN];</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">memset</span>(clientIP, <span class="number">0</span>, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line"></span><br><span class="line">                    inet_ntop(AF_INET, &amp;clientAddr, clientIP, INET_ADDRSTRLEN);</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"accept client ip : "</span> &lt;&lt; clientIP &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                    pollfds[maxNum].fd = connFd;</span><br><span class="line">                    pollfds[maxNum].events |= (POLLIN | POLLPRI);</span><br><span class="line">                    maxNum++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (--eventNum == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">//no need wait other </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> fd = pollfds[i].fd;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">memset</span>(buffers[fd], <span class="number">0</span>, <span class="keyword">sizeof</span>(buffers[fd]));</span><br><span class="line">                    <span class="keyword">int</span> len = recv(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//if len equal 0, mean client disconnect, we must add this condition, or else it will cause server crash</span></span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"client force close connection!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        pollfds[fd].fd = <span class="number">-1</span>;</span><br><span class="line">                        pollfds[fd].events |= <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                        maxNum--;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pollfds[i].events |= (POLLOUT | POLLWRBAND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollfds[i].revents &amp; (POLLOUT | POLLWRBAND)) &#123;</span><br><span class="line">                <span class="comment">//写事件</span></span><br><span class="line">                <span class="keyword">int</span> fd = pollfds[i].fd;</span><br><span class="line">                send(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                pollfds[i].events = POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-epoll"><a href="#2-3-epoll" class="headerlink" title="2.3 epoll"></a>2.3 epoll</h4><p>epoll的API比较多，还有epoll_create, epoll_ctl等，这里只列出epoll_wait, 其他的API建议使用 man 手册来查看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. epfd,epoll_create返回的fd</span></span><br><span class="line"><span class="comment">//2. events，事件列表，内含fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;	<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>epoll比poll更进一步，相比与poll来说，epoll_wait调用返回后不需要轮询fd了，只需要轮询事件数量即可。同时epoll支持两种事件触发模式，边沿触发（ET）和水平触发（LT）。而且epoll使用一个额为的fd(epoll_create创建)来管理多个fd，将用户监听的fd列表存放到内核的一个事件表中，这样的好处是减少用户空间和内核空间拷贝的次数（只需要一次， 其他调用需要拷贝所有的fd）</p>
<ul>
<li>边沿触发。当epoll_wait调用返回的时候，用户程序可以不处理该事件，下次epoll_wait会继续报告此事件，如果一直不处理事件，可能会导致busy loop.</li>
<li>水平触发。默认的工作模式，当epoll_wait调用返回的时候，用户程序必须处理该事件，否则会丢失事件。</li>
</ul>
<p>下面是一个使用epoll的示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processConn</span><span class="params">(<span class="keyword">int</span> connFd, struct in_addr clientAddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error socket!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="number">8000</span>;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenFd, (<span class="keyword">const</span> struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bind server error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenFd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"listen error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个epollfd</span></span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="comment">//设置epoll_event</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listenFd;</span><br><span class="line">    <span class="comment">//表示epoll新增监听listenFd的epoll_event事件</span></span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, listenFd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">revents</span>[1024];</span></span><br><span class="line">    <span class="keyword">char</span> buffers[<span class="number">1024</span>][BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> addrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eventNum = epoll_wait(epollfd, revents, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"event num "</span> &lt;&lt; eventNum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回结果会设置到revents里</span></span><br><span class="line">            <span class="keyword">if</span> (revents[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (revents[i].data.fd == listenFd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> connFd = accept(listenFd, (struct sockaddr *)&amp;clientAddr, &amp;addrLen);</span><br><span class="line">                    <span class="keyword">if</span> (connFd == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"accept error!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">char</span> clientIP[INET_ADDRSTRLEN];</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">memset</span>(clientIP, <span class="number">0</span>, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line"></span><br><span class="line">                    inet_ntop(AF_INET, &amp;clientAddr, clientIP, INET_ADDRSTRLEN);</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"accept client ip : "</span> &lt;&lt; clientIP &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">newEvent</span>;</span></span><br><span class="line">                    newEvent.events = EPOLLIN;</span><br><span class="line">                    newEvent.data.fd = connFd;</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_ADD, connFd, &amp;newEvent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> fd = revents[i].data.fd;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">memset</span>(buffers[fd], <span class="number">0</span>, <span class="keyword">sizeof</span>(buffers[fd]));</span><br><span class="line">                    <span class="keyword">int</span> len = recv(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//if len equal 0, mean client disconnect, we must add this condition, or else it will cause server crash</span></span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"client force close connection!!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="comment">//删除监听</span></span><br><span class="line">                        epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;revents[i]);</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    revents[i].events = EPOLLOUT;</span><br><span class="line">                    <span class="comment">//修改监听的事件类型</span></span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;revents[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (revents[i].events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = revents[i].data.fd;</span><br><span class="line">                send(fd, buffers[fd], <span class="keyword">sizeof</span>(buffers[fd]), <span class="number">0</span>);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">newEvent</span>;</span></span><br><span class="line">                newEvent.events = EPOLLIN;</span><br><span class="line">                newEvent.data.fd = fd;</span><br><span class="line">                <span class="comment">// epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;revents[i]);</span></span><br><span class="line">                epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;newEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenFd);</span><br><span class="line">    <span class="built_in">close</span>(epollfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>本文简单介绍了IO多路复用的概念，需要IO多路复用的理由，使用IO多路复用的好处以及Linux下几个IO多路复用接口的简单使用。</p>
<p>总结以下Linux下select，poll和epoll的特点和区别：</p>
<ol>
<li>select是最古老的实现，有最大监听fd数量的限制，而且需要一些无意义的遍历，因为遍历的size不是fd数量而是最大的fd值加1，导致事件不频繁的时候大量无意义循环。</li>
<li>poll虽然看起来没有遍历，实际上内部也是存在遍历。相比于select，最大的优势是没有最大fd的限制，同时编程难度也大于select。</li>
<li>epoll使用独立的fd来管理用户fd set，减少内核空间和用户空间的拷贝，不需要遍历所有监听的fd，这是性能上的提升。而且使用支持边沿触发和水平触发两种工作模式，相对更加灵活。但编程复杂度更上一层楼，很容易掉坑里。</li>
</ol>
<p>碍于篇幅，文中select,poll,epoll的介绍都非常简单（比如没有介绍poll和epoll支持的监听类型等等）， 详细的内容远不至于此，建议参考man手册或者网上一些优秀资料。</p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>