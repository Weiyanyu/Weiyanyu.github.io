<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeonon&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-07T09:36:32.398Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yeonon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 每日一题： 198. House Robber</title>
    <link href="http://yoursite.com/2017/07/07/198.%20House%20Robber/"/>
    <id>http://yoursite.com/2017/07/07/198. House Robber/</id>
    <published>2017-07-07T09:36:32.398Z</published>
    <updated>2017-07-07T09:36:32.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<blockquote>
<p>简单来说就是求数组中不相邻元素的最大和序列</p>
</blockquote>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxRob = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = max(pre + nums[i], maxRob);</div><div class="line">            pre = maxRob;</div><div class="line">            maxRob = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxRob;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>动态规划的思想（上篇文章讲到过），所以得找到三个要素，分别是最优子结构，状态转移方程，边界。</p>
<p>先假设一个函数F(N)，N代表N个数据（N个房子）,F（N）就是N个数据的序列。</p>
<p>通过分析，不难得出我们想要得到F(N)，可以先求出F(N-1)，然后取F(N-1)的最大值即可。<br>所以max(sum(F(N-1))) 应该就是F(N) 的最优子结构，从而可以得到状态转移方程: <strong>F(N)=max(sum(F(N-1)))</strong>，边界条件不难，就是F(1) = 序列首元素。</p>
<p>最后即可写出上述代码。</p>
<blockquote>
<p>注意上述方程中sum() 并不是简单的累加求和。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说就是求数组中不相邻元素的最大和序列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 70. Climbing Stairs</title>
    <link href="http://yoursite.com/2017/06/30/70.%20Climbing%20Stairs/"/>
    <id>http://yoursite.com/2017/06/30/70. Climbing Stairs/</id>
    <published>2017-06-30T12:50:39.665Z</published>
    <updated>2017-06-30T12:50:39.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given n will be a positive integer.</p>
<a id="more"></a>
<h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><p>暴力枚举，累加所有可能的情况即可。优点是简单粗暴，缺点就是复杂度是指数级别的，数据量稍微大一点就难以得出结果了。</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>先上代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = a + b;</div><div class="line">            a = b;</div><div class="line">            b = temp;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用<strong>动态规划</strong>的思想来解决，先找到最优子结构，注意最优子结构并不一定只有一个，例如这里我们不难得出我们要算出climbStairs(10)，可以先算出climbStairs(9) 和 climbStairs(8)（至于如何得出的，可以网上搜索一下，很容易可以搜到，在此不再赘述），这里climbStairs(9),climbStairs(8)就是climbStairs(10)的最优子结构，climbStairs(n) = climbStairs(n-1) + climbStairs(n-2) 就是状态转移方程，climbStairs(1) , climbStairs(0) 就是这种条件下的边界。确定了以上三要素，就可以使用动态规划的思想来解决问题了。</p>
<p>在上面，我们可以看到<strong>动态转移方程: climbStairs(n-1) + climbStairs(n-2)</strong></p>
<p>是不是有点想斐波那契数列的方程，斐波那契数列是递推，显然这里也是递推，这似乎是巧合，但是经过查找资料得出一个结论：</p>
<p><strong>动态规划其实就是递推</strong>. 更多关于动态规划的知识，各位可以网上搜索资料，或者看看算法导论，里面有专门的一章内容介绍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Given n will be a positive integer.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 572. Subtree of Another Tree</title>
    <link href="http://yoursite.com/2017/06/24/572.%20Subtree%20of%20Another%20Tree/"/>
    <id>http://yoursite.com/2017/06/24/572. Subtree of Another Tree/</id>
    <published>2017-06-24T15:45:59.686Z</published>
    <updated>2017-06-24T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<a id="more"></a>
<p>Example 1:<br>Given tree s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  4   5</div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<p>Given tree t:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  4 </div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<h3 id="第一种方法（暴力直接的方法）"><a href="#第一种方法（暴力直接的方法）" class="headerlink" title="第一种方法（暴力直接的方法）"></a>第一种方法（暴力直接的方法）</h3><p>代码不少，在这里我就不贴了，应该是没什么问题的。思路如下：</p>
<p>可以先遍历两颗树，将节点存入两个个vector里，确定谁可能是子树（Leetcode的题目已明确t是子树，这步在此题中就不是必要的了）。然后遍历非子树（直接遍历数组即可），直到找到和子树的根节点相同的节点，这时候就直接将子树挂载到找到的节点的父节点（这里查找方法可能有点麻烦，但是是可以实现的，注意不能直接对当前字节查询，因为我们需要知道父节点），然后再遍历新的树，最后和刚开始得到的非字树做比较，若完全相同，则返回True，否侧返回False。</p>
<p>这个方法着实麻烦，而且效率不高（虽然复杂度是O(N)，但是遍历次数较多）</p>
<h3 id="第二种方法-Leetcode网友分享"><a href="#第二种方法-Leetcode网友分享" class="headerlink" title="第二种方法 (Leetcode网友分享)"></a>第二种方法 (Leetcode网友分享)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; nodes;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        getDepth(s, getDepth(t, <span class="number">-1</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : nodes) &#123;</div><div class="line">            <span class="keyword">if</span> (isSame(n, t))</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *node, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> depth = max(getDepth(node-&gt;left, d), getDepth(node-&gt;right, d)) + <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (depth == d)</div><div class="line">            nodes.push_back(node);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> depth;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *a, TreeNode *b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (!a || !b || a-&gt;val != b-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> isSame(a-&gt;left, b-&gt;left) &amp;&amp; isSame(a-&gt;right, b-&gt;right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法就是先获取子树的深度，然后再去找非子树的深度，在找的过程中可能会碰到和子树深度相同的树（即非子树的子树），找到之后将节点放入数组中，最后遍历数组，拿数组中元素（节点）与子树递归比较即可得出结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 122. Best Time to Buy and Sell Stock II</title>
    <link href="http://yoursite.com/2017/06/19/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/"/>
    <id>http://yoursite.com/2017/06/19/122. Best Time to Buy and Sell Stock II/</id>
    <published>2017-06-19T11:25:15.029Z</published>
    <updated>2017-06-19T11:25:15.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Say you have an array for which the i th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<a id="more"></a>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>])</div><div class="line">                maxPro = max(maxPro + (prices[i] - prices[i<span class="number">-1</span>]), maxPro);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxPro;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>简单的贪心，直接寻找最优解，每次都取最大值即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Say you have an array for which the i th element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 169. Majority Element</title>
    <link href="http://yoursite.com/2017/06/18/169.%20Majority%20Element/"/>
    <id>http://yoursite.com/2017/06/18/169. Majority Element/</id>
    <published>2017-06-18T10:28:15.089Z</published>
    <updated>2017-06-18T10:28:15.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<a id="more"></a>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</div><div class="line">            <span class="built_in">map</span>[n]++;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> N = nums.size() / <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : <span class="built_in">map</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p.second &gt; N)</div><div class="line">                <span class="keyword">return</span> p.first;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>直接使用map统计出现次数，最后返回出现次数大于2/n的键就行了。很简单，重点看看第二种方法。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> majorityIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">1</span>; i &lt; num.size(); i++) &#123;</div><div class="line">            num[majorityIndex] == num[i] ? count++ : count--;</div><div class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                majorityIndex = i;</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">return</span> num[majorityIndex];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是Leetcode网友给出的解答，使用了Moore’s voting algorithm（摩尔投票算法），在这大致说一下，遍历数组，和当前majorityIndex的数做比较，如果一样就让计数器加1，不同则减1，若count减到0了（说明这个下标索引的肯定不是最终结果）,就重新让count=1，majorityIndex = i(即另取一个值)，最后返回这个下标索引的值即可。</p>
<p>关于摩尔投票算法，可以看看这篇文章  <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm</a></p>
<p>还有这个website，可以试试<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/" target="_blank" rel="external">https://www.cs.utexas.edu/~moore/best-ideas/mjrty/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 387. First Unique Character in a String</title>
    <link href="http://yoursite.com/2017/06/18/387.%20First%20Unique%20Character%20in%20a%20String/"/>
    <id>http://yoursite.com/2017/06/18/387. First Unique Character in a String/</id>
    <published>2017-06-18T09:37:09.351Z</published>
    <updated>2017-06-18T09:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<a id="more"></a>
<p>Example:<br>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</div><div class="line">            ++<span class="built_in">map</span>[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] == <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>直接使用map保存字符出现的次数，然后在遍历，若碰到正好只出现一次的情况，直接返回下标即可。注意这里直接使用了map []操作符是因为我们遍历的是同一个字符串，不会出现其他字符，所以不用担心会添加其他字符。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>其实也是 使用map，但是这时候要多保存一下索引，因为我们可能不希望遍历两次数组（数组太大）。代码就不贴了，不是很费劲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 167. Two Sum II - Input array is sorted</title>
    <link href="http://yoursite.com/2017/06/16/167.Two_Sum_II_Input_array_is_sorted/"/>
    <id>http://yoursite.com/2017/06/16/167.Two_Sum_II_Input_array_is_sorted/</id>
    <published>2017-06-16T15:12:08.627Z</published>
    <updated>2017-06-16T15:12:08.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<a id="more"></a>
<p>Example:<br>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] == target)</div><div class="line">                <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target)</div><div class="line">                r--;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                l++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为已知输入序列是已排序的，所以可以从两边向中间查找，若当前结果比目标大，则右边指针-1，反之，右边指针+1。</p>
<h3 id="第二种方法-二分查找"><a href="#第二种方法-二分查找" class="headerlink" title="第二种方法(二分查找)"></a>第二种方法(二分查找)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target, <span class="keyword">int</span> lo)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hi = numbers.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</div><div class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (numbers[mid] == target)</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target)</div><div class="line">                hi = mid - <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                lo = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i) &#123;</div><div class="line">            <span class="keyword">int</span> other = target - numbers[i];</div><div class="line">            <span class="keyword">int</span> result = BS(numbers, other, i+<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> &#123;i+<span class="number">1</span>,result+<span class="number">1</span>&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路是用二分查找 去寻找目标值减去当前值。若找到，则直接返回。</p>
<p>这里有个细节得注意，二分查找的方法并不适用输入序列未排序和一些已经排序，但是有多个重复值的情况，因为题目要求返回第一个符合目标的下标对，但是二分查找的结果不一定是第一个符合目标的下标。</p>
<p>未排序不适用不难理解，但是有些已排序的情况就可能不那么明显了（Leetcode的题目不包含这种情况，不过这里做个小扩展吧）。</p>
<p>例如：</p>
<p>输入序列是： 2,3,3,3,4， 目标是 5，<br>如果按照二分查找的方法，结果是 [1,3]，但是Leetcode OJ的正确答案应该是 [1,4]，Leetcode的答案似乎也不正确(其实是因为题目本身不包含这种情况，上面已经说到)，但是我们应该知道正确答案应该是 [1,2]。</p>
<p>这里就是因为二分查找首先在中间位置index = 2(从0开始索引)找到了符合要求的结果，所以直接返回了，这就是这种方法不能解决的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.&lt;/p&gt;
&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution and you may not use the same element twice.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2017/06/11/226.Invert_Binary_Tree/"/>
    <id>http://yoursite.com/2017/06/11/226.Invert_Binary_Tree/</id>
    <published>2017-06-11T10:51:16.381Z</published>
    <updated>2017-06-11T10:51:16.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Invert a binary tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div></pre></td></tr></table></figure></p>
<p>to<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="第一种方法-递归"><a href="#第一种方法-递归" class="headerlink" title="第一种方法(递归)"></a>第一种方法(递归)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">        swap(root-&gt;left, root-&gt;right);</div><div class="line">        <span class="keyword">if</span> (root-&gt;left) invertTree(root-&gt;left);</div><div class="line">        <span class="keyword">if</span> (root-&gt;right) invertTree(root-&gt;right);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>递归的交换左子树和右子树，思路很简单，递归也不难理解。</p>
<h3 id="第二种方法-非递归"><a href="#第二种方法-非递归" class="headerlink" title="第二种方法(非递归)"></a>第二种方法(非递归)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* invertTree(TreeNode* root) &#123;</div><div class="line">        stack&lt;TreeNode *&gt; s;</div><div class="line">        s.push(root);</div><div class="line">        while (!s.empty()) &#123;</div><div class="line">            TreeNode *p = s.top();</div><div class="line">            s.pop();</div><div class="line">            if (p) &#123;</div><div class="line">                if (p-&gt;left) s.push(p-&gt;left);</div><div class="line">                if (p-&gt;right) s.push(p-&gt;right);</div><div class="line">                swap(p-&gt;left, p-&gt;right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用栈作为暂时存储容器（也可以用队列，这里对于顺序不敏感）,分别交换栈顶节点的左子树和右子树（即使为空）.</p>
<p><strong>Ps:</strong> : 对于树的问题，往往既可以用递归，也可以用循环来解决，经常也是递归代码比较简洁，但有时候可能比较难以理解，循环往往比较容易理解。值得注意的是，系统的栈深度是有上限的（虽然可以调，但是付出的代价不小），如果树的深度值太大，很有可能会出现栈内存不够用的情况，从而导致程序崩溃（而且在有点情况下，直到程序运行了一段时间才能发现这个问题）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Invert a binary tree.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;     4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   /   \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  2     7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; / \   / \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1   3 6   9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;to&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;     4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   /   \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  7     2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; / \   / \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9   6 3   1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 389. Find the Difference</title>
    <link href="http://yoursite.com/2017/06/10/389.Find_the_Difference/"/>
    <id>http://yoursite.com/2017/06/10/389.Find_the_Difference/</id>
    <published>2017-06-10T12:33:51.955Z</published>
    <updated>2017-06-10T12:33:51.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input:<br>s = “abcd”<br>t = “abcde”</p>
<p>Output:<br>e</p>
<p>Explanation:<br>‘e’ is the letter that was added.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>使用哈希表，比较直接，不贴代码了。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</div><div class="line">            res ^= c;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t)</div><div class="line">            res ^= c;</div><div class="line">            </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实这道题和<a href="https://leetcode.com/problems/single-number/#/description" target="_blank" rel="external">这道题</a>简直就是异曲同工，两个相同的数做异或结果是0,0和任意数异或结果是该数，所以这里遍历两个字符串，最后结果单独的，即single-number。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given two strings s and t which consist of only lowercase letters.&lt;/p&gt;
&lt;p&gt;String t is generated by random shuffling string s and then add one more letter at a random position.&lt;/p&gt;
&lt;p&gt;Find the letter that was added in t.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2017/06/10/104.Maximum_Depth_of_Binary_Tree/"/>
    <id>http://yoursite.com/2017/06/10/104.Maximum_Depth_of_Binary_Tree/</id>
    <published>2017-06-10T12:08:42.071Z</published>
    <updated>2017-06-10T12:08:42.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<a id="more"></a>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>深度优先搜索(DFS)，前序遍历的方式遍历树节点。然后递归的统计左边和右边深度的最大值，最后返回即可，代码就两行（可写成一行）,但是其中思想还是很重要的。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>class Solution {<br>public:<br>    int maxDepth(TreeNode* root) {<br>        if (root == nullptr) return 0;<br>        int res = 0;</p>
<pre><code>    queue&lt;TreeNode *&gt; q;
    q.push(root);

    while (!q.empty()) {
        ++res;
        for (int i = 0,n = q.size(); i &lt; n; ++i) {
            TreeNode *p = q.front();
            q.pop();
            if (p-&gt;left)
                q.push(p-&gt;left);
            if (p-&gt;right)
                q.push(p-&gt;right);
        }
    }

    return res;
}
</code></pre><p>};</p>
<p>广度优先搜索（BFS），层序遍历即可，利用队列，思路不难也比较容易理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 448. Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2017/06/09/448.Find_All_Numbers_Disappeared_in_an_Array/"/>
    <id>http://yoursite.com/2017/06/09/448.Find_All_Numbers_Disappeared_in_an_Array/</id>
    <published>2017-06-09T13:21:16.823Z</published>
    <updated>2017-06-09T13:21:16.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[5,6]</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            s.insert(n);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (s.find(i+<span class="number">1</span>) == s.end())</div><div class="line">                res.push_back(i+<span class="number">1</span>);</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个是比较容易想到的方法（比较直接）,思路是将所有碰到的下标放入一个无序无重复的set里，然后从1开始查找，如果不存在，就在结果里添加即可。时间复杂度就是O(N) 了，主要在循环插入和遍历元素上（unordered_set的插入时间和查找时间都是O(1)）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> m = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</div><div class="line">            nums[m] = nums[m]&gt;<span class="number">0</span> ? -nums[m] : nums[m];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) res.push_back(i+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法就有点技巧了。遍历nums数组,将对应下标（注意要减1才是对应下标）的元素设为负的，最后遍历nums数组找出是正的就行，这里要注意一下数组里元素比对应下标大1。这里时间复杂度也是O(N),但是没有额外的空间消耗（res那个数组是必须的），但是也有个弊端，如果题目要求不能改变原数组，为了继续用这种方法，就不得不复制一个数组（参数非引用即可），这样空间复杂度可能还不如第一种方法，因为第一种方法不保存重复的元素，根据此题，set的大小（不包括类的其他成员占的空间）肯定比原数组大小要小。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.&lt;/p&gt;
&lt;p&gt;Find all the elements of [1, n] inclusive that do not appear in this array.&lt;/p&gt;
&lt;p&gt;Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 485. Max Consecutive Ones</title>
    <link href="http://yoursite.com/2017/06/08/485.Max_Consecutive_Ones/"/>
    <id>http://yoursite.com/2017/06/08/485.Max_Consecutive_Ones/</id>
    <published>2017-06-08T08:37:07.944Z</published>
    <updated>2017-06-08T08:37:07.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Note:</p>
<p>The input array will only contain 0 and 1.<br>The length of input array is a positive integer and will not exceed 10,000</p>
<a id="more"></a>
<p>Example:</p>
<p>Input: [1,1,0,1,1,1]<br>Output: 3<br>Explanation: The first two digits or the last three digits are consecutive 1s.The maximum number of consecutive 1s is 3.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">                maxcount = max(++count, maxcount);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                count = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxcount;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>基本算是暴力解法了，也有点动态规划的意思，有状态，有状态转移，求出最优解。</p>
<p>应该没有更好的解法了，因为怎么说都要遍历一遍数组，至少都是O(N).取最大值那块也许可以优化一下，如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">                ++count;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                maxcount = max(count, maxcount);</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max(count, maxcount);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样把取最大值放到了当n == 0 时，因为根据所求是连续的1，所以猜想数据有可能 1 的个数比 0 多，如果确是如此，那比较次数就能减少了。这种情况在庞大的数据里也是存在的，比如矩阵，经常是0比较多。</p>
<blockquote>
<p>以上两种方式（算不上两种方法），应根据数据特点选择使用。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a binary array, find the maximum number of consecutive 1s in this array.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;The input array will only contain 0 and 1.&lt;br&gt;The length of input array is a positive integer and will not exceed 10,000&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 463. Island Perimeter</title>
    <link href="http://yoursite.com/2017/06/06/463.Island_Perimeter/"/>
    <id>http://yoursite.com/2017/06/06/463.Island_Perimeter/</id>
    <published>2017-06-06T14:40:00.363Z</published>
    <updated>2017-06-06T14:40:00.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<a id="more"></a>
<p>Example:</p>
<p>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p>
<p>Answer: 16</p>
<blockquote>
<p>求边数，注意公共边</p>
</blockquote>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="number">1</span>) repeatCount++;</div><div class="line">                    <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>] == <span class="number">1</span>) repeatCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="number">4</span> * count - <span class="number">2</span> * repeatCount;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>画出图后，找找规律应该很明白了，主要要减去重复的边数，值得注意的是数组不要越界，所以要有一定的检查，上面的代码采用的是取左上的方式，当然也可以是是右上，左下等等，只要是任意两边就行，为方便，故取左上（右下也挺方便的）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 496. Next Greater Element I</title>
    <link href="http://yoursite.com/2017/06/06/496.Next_Greater_Element_I/"/>
    <id>http://yoursite.com/2017/06/06/496.Next_Greater_Element_I/</id>
    <published>2017-06-06T14:06:13.495Z</published>
    <updated>2017-06-06T14:06:13.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>Output: [-1,3,-1]<br>Explanation:<br>    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br>    For number 1 in the first array, the next greater number for it in the second array is 3.<br>    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</p>
<blockquote>
<p>这里可能要说明一下题目，注意到下一个比它大的值，这里一旦找到第一个比它大的就停止了，即使后面有更大，也不需要了，这点很关键。</p>
</blockquote>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">while</span> (s.size() &amp;&amp; s.top() &lt; n) &#123;</div><div class="line">                <span class="built_in">map</span>[s.top()] = n;</div><div class="line">                s.pop();</div><div class="line">            &#125;</div><div class="line">            s.push(n);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : findNums) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.count(n) &gt; <span class="number">0</span>) </div><div class="line">                res.push_back(<span class="built_in">map</span>[n]);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                res.push_back(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>主要是使用栈和关联表这种数据结构，其实使用stack的目的就是保存数据，其实使用数组也可以，但是诸多不便。</p>
<p>这里根据题意就可以组织关联表了，比如上面那个例子中，仅仅建立当前值与栈顶值(即当前值之前所有未建立关系的值)的关联关系，具体的代码中很清晰了。有两个需要注意的地方，一是第一个for循环里的while循环，这里要不断拿当前值和栈中的值做比较，直到没有满足条件的值，二是map.count(n) ，如果直接使用map[n] 会导致添加无用的值。</p>
<p><strong>Ps:</strong> : 这题不能排序，因为顺序在这道题很重要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.&lt;/p&gt;
&lt;p&gt;The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 500. Keyboard Row</title>
    <link href="http://yoursite.com/2017/06/06/500.Keyboard_Row/"/>
    <id>http://yoursite.com/2017/06/06/500.Keyboard_Row/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.(这里Image就不贴上来了，就是大多数键盘的布局)</p>
<a id="more"></a>
<p><strong>Example:</strong><br>Input: [“Hello”, “Alaska”, “Dad”, “Peace”]<br>Output: [“Alaska”, “Dad”]</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>暴力解决，逻辑可能会有些不清晰，不过比较简单直接</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row1 = &#123;<span class="string">'q'</span>,<span class="string">'w'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'t'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>&#125;;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row2 = &#123;<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row3 = &#123;<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>,<span class="string">'v'</span>,<span class="string">'b'</span>,<span class="string">'n'</span>,<span class="string">'m'</span>&#125;;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; rows = &#123;row1,row2,row3&#125;;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.size();i++)&#123;</div><div class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows.size();j++)&#123;</div><div class="line">                <span class="keyword">if</span> (rows[j].count((<span class="keyword">char</span>)<span class="built_in">tolower</span>(words[i][<span class="number">0</span>])) &gt; <span class="number">0</span>) row = j;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; words[i].size();k++)&#123;</div><div class="line">                <span class="keyword">if</span> (rows[row].count((<span class="keyword">char</span>)<span class="built_in">tolower</span>(words[i][k])) == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (k == words[i].size() - <span class="number">1</span>) res.push_back(words[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里使用unordered_set 这种数据结构（无序的集合，不可重复）。然后遍历每个单词，在内循环中找出每个单词第一个字母出现的行数（这里的行 指的是 键盘上的行，共有三行），最后再在遍历单词的每个字母，判断是否是每个字符都在同一行的情况，若是，往结果里添加相应的单词，否则选择忽略该单词，继续遍历或停止。</p>
<p><strong>Ps</strong> : 这里使用也可以使用set，但是注意在C++ 里 set 是用红黑树实现，插入时间和查找时间都是O(logN)，而unordered_set 使用 哈希表（散列表） 实现的，查询时间分摊后 大概是 O(1)，插入时间也是O(1)。对于本题，因为在集合里数据较少，所以当输入数据规模较大时，这两种数据结构之间的差异就比较明显了（主要是查找上），规模小的情况下，差异不大。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.(这里Image就不贴上来了，就是大多数键盘的布局)&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 561. Array Parition I</title>
    <link href="http://yoursite.com/2017/06/06/561.Array_Partition_I/"/>
    <id>http://yoursite.com/2017/06/06/561.Array_Partition_I/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: [1,4,3,2]</p>
<p>Output: 4<br>Explanation: n is 2, and the maximum sum of pairs is 4.</p>
<h3 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = num;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</div><div class="line">            temp /= <span class="number">2</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        temp = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            num = num ^ temp;</div><div class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路是先算出该整数的最大有效位数，通过不断除以2，计数直至该整数为0为止。然后就是核心部分了，使用异或运算，初始时使用1与之异或，然后左移变量(即代码中的temp)。最终即可得到答案。</p>
<p>这里还是举个例子吧，便于理解。比如要求的整数是5（二进制101，下同），我们先确定最大有效位数（即3），然后先做 1 ^ 5 (结果是100，即4)，接着1左移1位（010），注意此时整数已经被赋值为4了，紧接着4(100) 与 2 (010) 再异或，010 再左移，如此循环即可，最终返回num.</p>
<p><strong>Ps</strong>: 这里有更方便的方法，用bitset的 flip() 方法，直接翻转。最后再转换成整形即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 575. Distribute Candies</title>
    <link href="http://yoursite.com/2017/06/06/575.Distribute_Candies/"/>
    <id>http://yoursite.com/2017/06/06/575.Distribute_Candies/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: candies = [1,1,2,2,3,3]<br>Output: 3<br>Explanation:<br>There are three different kinds of candies (1, 2 and 3), and two candies for each kind.<br>Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.<br>The sister has three different kinds of candies. </p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashtable;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; candies.size(); ++i) &#123;</div><div class="line">            hashtable.insert(candies[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> eachSize = candies.size() / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> kindSize = hashtable.size();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> kindSize &gt; eachSize ? eachSize : kindSize;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用哈希表来存储种类，经过观察，找到规律发现当种类不足总数的一半时，结果是种类数，当种类超过总数一半时，结果就是总数一半（这里很自然，因为两人是平分的，种类数不可能超过分到的数目），这样就完事了，很简单。这里的时间复杂度是O(N)（循环的时间），空间复杂度也是O(N) （存表需要的线性空间）。下面来看第二种方法。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</div><div class="line">        <span class="keyword">size_t</span> kinds = <span class="number">0</span>;</div><div class="line">        sort(candies.begin(), candies.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.size(); i++) &#123;</div><div class="line">            kinds += i == <span class="number">0</span> || candies[i] != candies[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min(kinds, candies.size() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种方式为方便找到种类数，先进行排序，处理结果的方式同第一种方法，核心就是要找到种类数。这里时间复杂度是O(NlogN) (sort排序花费时间占大头，但是这只是平均时间复杂度，因为C++ 的sort 会根据容器大小来决定使用哪种排序，并不仅仅是快排)，空间复杂度是O(1)，并没有占用额外的空间。</p>
<p><strong>Note:</strong> 以上两种方式都很好，主要是看应用场景，如果空间较紧张，哈希表的方式显然不合适，因为数据大的话很有可能会生成庞大的哈希表，这时候就应采用第二种方式了，用时间换空间。反之，对性能要求较高，而空间不是那么紧张的话，就可以采用第一种方式了。当然，还有第三种情况就是对性能要求较高，而空间也相对紧张（比如一些嵌入式应用），这时候就要看侧重点了，得具体问题做详细分析。</p>
<blockquote>
<p>这题显然是一道很简单的题目，但是写了不少，原因是想说明再简单的问题，也会因为使用数据结构或算法不当而导致BUG，亦不可因为简单而掉以轻心。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 557. Reverse Words in a String III</title>
    <link href="http://yoursite.com/2017/06/06/557.Reverse_Words_in_String_III/"/>
    <id>http://yoursite.com/2017/06/06/557.Reverse_Words_in_String_III/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</div><div class="line">    	<span class="built_in">string</span> temp;</div><div class="line">    	<span class="built_in">string</span> res;</div><div class="line">    	<span class="keyword">while</span> (ss &gt;&gt; temp) &#123;</div><div class="line">    		reverse(temp.begin(), temp.end());</div><div class="line">    		res = res + temp + <span class="string">" "</span>;</div><div class="line">    	&#125;</div><div class="line">    	res.erase(res.end() - <span class="number">1</span>, res.end());</div><div class="line">    	<span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是第一种方法，使用stringstream类来方便分割字符串（空格分割），然后对每一个单词做翻转就行了。（注意最后的空格）</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">size_t</span> front = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(i == s.length() || s[i] == <span class="string">' '</span>)&#123;</div><div class="line">                reverse(&amp;s[front], &amp;s[i]);</div><div class="line">                front = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是方法是Leetcode网友分享的，思路也比较简单（类似这种方法，也可以用迭代器实现，不过可能有些许麻烦）</p>
<p><strong>Ps</strong> : 这道题如果用python，一行就能搞定 return “ “.join(map(lambda x: x[::-1], s.split())) </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 566 Reshape the Matrix</title>
    <link href="http://yoursite.com/2017/06/06/566.Reshape_the_Matrix/"/>
    <id>http://yoursite.com/2017/06/06/566.Reshape_the_Matrix/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br>Output:<br>[[1,2,3,4]]<br>Explanation:<br>The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>代码就不贴了，直接暴力解决，写两个for循环就行，时间复杂度应该是O(n²)</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</div><div class="line">        <span class="keyword">int</span> row = nums.size();</div><div class="line">        <span class="keyword">int</span> col = nums[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> cap = row * col;</div><div class="line">        <span class="keyword">if</span> (r * c != cap) <span class="keyword">return</span> nums;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c,<span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cap; ++i) &#123;</div><div class="line">            res[i / c][i % c] = nums[i / col][i % col];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>很好的一种方法（我第一次遇到，真是想不到这种方法，这是参考Leetcode网友的答案）.<br>原理是按照先行后列的方式读取原矩阵的元素，然后放置到新数组中相应的位置。<br>放置的方式也是按照先行后列的方式放置，所以有了这行代码 : <strong>res[i / c][i % c] = nums[i / col][i % col];</strong>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.&lt;/p&gt;
&lt;p&gt;You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.&lt;/p&gt;
&lt;p&gt;The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.&lt;/p&gt;
&lt;p&gt;If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 476. Number Complement</title>
    <link href="http://yoursite.com/2017/06/06/476.Number_Complement/"/>
    <id>http://yoursite.com/2017/06/06/476.Number_Complement/</id>
    <published>2017-06-06T14:05:09.187Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<a id="more"></a>
<p><strong>Exampe:</strong></p>
<p>Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p>
<h3 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = num;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</div><div class="line">            temp /= <span class="number">2</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        temp = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            num = num ^ temp;</div><div class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路是先算出该整数的最大有效位数，通过不断除以2，计数直至该整数为0为止。然后就是核心部分了，使用异或运算，初始时使用1与之异或，然后左移变量(即代码中的temp)。最终即可得到答案。</p>
<p>这里还是举个例子吧，便于理解。比如要求的整数是5（二进制101，下同），我们先确定最大有效位数（即3），然后先做 1 ^ 5 (结果是100，即4)，接着1左移1位（010），注意此时整数已经被赋值为4了，紧接着4(100) 与 2 (010) 再异或，010 再左移，如此循环即可，最终返回num.</p>
<p><strong>Ps</strong>: 这里有更方便的方法，用bitset的 flip() 方法，直接翻转。最后再转换成整形即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
