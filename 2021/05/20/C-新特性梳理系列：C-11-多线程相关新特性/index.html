<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Yeonon&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            C++新特性梳理系列：C++11 多线程相关新特性
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文不会对多线程的概念进行介绍，仅对C++11新增的多线程相关的工具和库进行介绍</p>
</blockquote>
<p>在C++11之前，要编写多线程程序的话，一般都会使用pthread，例如创建线程用pthread_create，互斥量则使用pthread_mutex_xx系列函数，条件变量使用pthread_cond_xx系列函数等等，严格意义上来说，这不算是C++语言上支持的东西。而是Linux系统提供的，更准确的说是Linux实现了<strong>POSIX线程标准</strong>描述的API，这些API都是pthread_开头。作为对比，下面是简单看一个使用pthread库的示例，如果对这些API比较了解的话，可以跳过这部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">addCount</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//lock</span></span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line">        g_count++;</span><br><span class="line">        <span class="comment">//unlock</span></span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化mutex</span></span><br><span class="line">    pthread_mutex_init(&amp;g_mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> th1, th2;</span><br><span class="line">    pthread_create(&amp;th1, <span class="literal">NULL</span>, addCount, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;th2, <span class="literal">NULL</span>, addCount, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻塞主线程，直到两个线程执行结束</span></span><br><span class="line">    pthread_join(th1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(th2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result count : "</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例就是多线程编程中的“Hello World”，很简单，不多解释了。可以看到这个示例给人的感觉很“古老”，不够“新”（但这不代表代码不好），感觉就是在写C语言代码，确实，这段代码移植到C语言中几乎没有任何问题（如果移植到其他操作系统平台可能会比较麻烦，因为并不是所有操作系统都实现了POSIX线程标准API，比如windows）。等后面介绍C++11中多线程的新特性之后，再重写一下这段代码，使其更加的“现代化”，那么现在开始正式介绍C++11中新增的多线程相关特性。                                                     </p>
<h2 id="C-11中的多线程"><a href="#C-11中的多线程" class="headerlink" title="C++11中的多线程"></a>C++11中的多线程</h2><p>C++11终于对多线程在语言层面上提供了支持，新增了5个头文件，分别是：</p>
<ul>
<li><code>&lt;atomic&gt;</code>，包含了对原子类型的支持。</li>
<li><code>&lt;thread&gt;</code>，主要是std::thread线程类，该类提供几个方便的函数，例如join，detach等。</li>
<li><code>&lt;mutex&gt;</code>，包含了互斥量相关的类，包含来常用的lock_guard（作用类似android上封装的AUTO LOCK）。</li>
<li><code>&lt;condition_variable&gt;</code>，包含了条件变量相关的类。</li>
<li><code>&lt;future&gt;</code>，包含了对future模式的支持，即异步编程的支持。</li>
</ul>
<p>使用这些头文件提供的类或者函数都是跨平台，在不同的平台上，会使用不同的底层实现，例如在Linux下就使用pthread那套，在windows下就使用windows那套，这是这套多线程工具库的优点之一。除此之外，这些类或者函数都比直接使用平台的API更简单方便，接下来将逐个对这些头文件中常用的一些类或者函数作介绍。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>首先就是<code>&lt;thread&gt;</code>头文件，该头文件包含的东西不多，主要是std::thread类以及几个实用的函数，例如get_id，sleep_for（包含在this_thread namespace里）等。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>创建线程的方法很简单，创建线程对象即可。std::thread有3个可用的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread() <span class="keyword">noexcept</span>;   <span class="comment">//构造一个空的线程对象</span></span><br><span class="line"></span><br><span class="line">thread( thread&amp;&amp; other ) <span class="keyword">noexcept</span>;  <span class="comment">//移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">explicit</span> <span class="title">thread</span>( <span class="title">Function</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span>   <span class="comment">//接受传入一个可调用对象，以及其参数</span></span><br></pre></td></tr></table></figure>

<p>其拷贝构造是被显式设置为delete的，所以thread对象不支持拷贝。特别的，空的线程对象并不能代表一个线程，请注意。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBoringThing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//this_thread::get_id() 获取当前线程的线程id</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">"print: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">th1</span><span class="params">(doBoringThing)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">th2</span><span class="params">(doBoringThing)</span></span>;</span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result count : "</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比使用pthread_create简单一些吧，而且对线程执行函数的签名（pthread要求返回值和参数都是void*类型）没有了严格要求，这得益于模板以及可变模板参数特性。</p>
<p>std::thread类有几个常用的函数也值得说一下：</p>
<ul>
<li>join，上面示例用到了，和pthread_join作用一样，阻塞当前线程，等待目标线程返回。示例中是阻塞主线程。</li>
<li>get_id()，和示例用的this_thread::get_id()不同，std::thread::get_id()拿到的是本线程对象的线程id，只要能拿到线程对象，无论现在是否是该线程执行，都可以拿到对应的id。</li>
<li>detach，分离线程，和pthread_detach作用一样，简单来说就是脱离线程对象的控制，线程结束了马上就释放资源。</li>
<li>swap，交换两个线程对象。</li>
<li>joinable，线程是有几个状态的，joinable就是其中一个，这个函数用来判断线程的状态是否是joinable。</li>
</ul>
<p>其他函数比如native_handle，hardware_concurrency使用不同，有兴趣的话可以自行查阅文档（我也是看的文档….）。this_thread下也还有几个函数，也一样，这种东西看文档一下就知道了，有兴趣查阅文档吧。</p>
<h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><h5 id="常用的几个互斥量"><a href="#常用的几个互斥量" class="headerlink" title="常用的几个互斥量"></a>常用的几个互斥量</h5><p><code>&lt;mutex&gt;</code>头文件中的主要内容是互斥量，互斥量是在多线程同步是使用最广泛的工具，通过对互斥量加锁和解锁来控制多线程同步。C++11中几个常用的互斥量有：</p>
<ul>
<li>std::mutex，最简单朴素的互斥量，具有完整的互斥语义。</li>
<li>std::recursive_mutex，可递归的互斥量，允许同一个线程多次访问，可以降低死锁的风险。</li>
<li>std::timed_mutex，作用同std::mutex，提供了超时的功能，可结合std::try_lock_for和std::try_lock_until使用。</li>
<li>std::recursive_timed_mutex，作用同std::recursive_mutex，同样提供了超时功能。</li>
</ul>
<p>上述几个互斥量都提供了lock,unlock,try_lock函数，从名字就可以看出来其作用，不多解释了。现在可以重写本文一开始的那个累加的程序了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        m.lock();</span><br><span class="line">        count++;</span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意一下这里传递addCount的参数时，由于addCount的两个参数是引用类型，而模板参数无法推导引用类型，所以这里我们需要使用std::ref来返回一个	 std::reference_wrapper，进而辅助模板参数决定是否该使用引用传递</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(addCount, <span class="built_in">std</span>::ref(m), <span class="built_in">std</span>::ref(count))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(addCount, <span class="built_in">std</span>::ref(m), <span class="built_in">std</span>::ref(count))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result: "</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个程序看起来是不是更像C++了，更“现代”一些了（当然，程序太过简单，也许没有太大感受）。下面再看一下recursive_mutex的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boringFunc1</span><span class="params">(<span class="built_in">std</span>::recursive_mutex&amp; rm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rm.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" access boringFunc1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    rm.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boringFunc2</span><span class="params">(<span class="built_in">std</span>::recursive_mutex&amp; rm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rm.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" access boringFunc2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boringFunc1(rm);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" back access boringFunc2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    rm.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex rm;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(boringFunc1, <span class="built_in">std</span>::ref(rm))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(boringFunc2, <span class="built_in">std</span>::ref(rm))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里boringFunc2会去访问boringFunc1，然后继续对互斥量进行lock，由于这是递归的互斥量，所以这里是可以上锁成功的。如果是普通的std::mutex，则这里肯定会死锁。实际上，递归锁也可以叫做可重入锁，因为可重入的语义打破了死锁的一个必要条件：不可重入。所以使用std::recursive_mutex是避免死锁的一种方法。</p>
<p>另外两个是具备超时机制的，需要结合try_lock来使用，这个机制可以防止长时间阻塞从而降低效率，大多数使用场景就是轮询以及异步，如果各位有兴趣的话，可以自行尝试写写demo，这里就不多介绍了。接下来继续看其他部分内容。</p>
<h5 id="两个互斥量的wapper"><a href="#两个互斥量的wapper" class="headerlink" title="两个互斥量的wapper"></a>两个互斥量的wapper</h5><p>下面是两个对互斥量的wapper：    </p>
<ul>
<li><p>std::lock_guard，这是一个模板类，通过一个互斥量来初始化lock_guard对象。其作用就是构造对象的时候lock，在出作用域并且析构的时候unlock，和android上的auto_lock作用差不多。</p>
</li>
<li><p>unique_lock，也是一个模板类，其具备lock_guard的所有功能，并且在此基础上提供了延迟加锁的功能，但后续需要手动lock，同时后面将会介绍到的条件变量也必须使用unique_lock来包装。unique_lock不能复制，这也是unique的意义，unique_lock构造时可以接受第二个参数，表示对象构造时对互斥量要采取的行为，分别是：</p>
<ul>
<li>std::try_lock_t，表示尝试去加锁，如果锁的状态是不可用的，也会立即返回，不会阻塞线程。不过使用这个东西也有个坑，如果使用的互斥量是std::mutex，并且线程已经获取到mutex对象，即加锁成功，那再次执行try_lock将是未定义的行为，请小心使用。</li>
<li>std::defer_lock_t，表示延迟加锁，后续是否要lock都需要用户自行决定。</li>
<li>std::adopt_lock_t，表示假设绑定的这个mutex已经加过锁了。std::lock_guard可以也只能使用这个选项。</li>
</ul>
<p>无论使用上述哪个选项，如果对应的mutex已经加锁了，那么当unique_lock析构的时候就要解锁。</p>
</li>
</ul>
<p>使用std::lock_guard和unique_lock对之前的累加程序作小小修改，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock_guard</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单对吧，使用lock_guard包装mutex，就不需要关心unlock了。当然，如果需要更加细致的控制，完全可以开一个新的作用域，{}包裹起来即可。因为unique_lock包含了lock_guard的所有功能，所以上面改成使用unique_lock也是没有问题的，只是可能没必要。下面一个例子展示了unique_lock独有的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deferLockTest</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::system_clock::now();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">        lock.lock(); <span class="comment">//需要手动lock，使用std::defer_lock参数的话，构造对象时实际并没有加锁，各位可以验证一下</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deferLockTest run time: "</span> &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="built_in">end</span> - start).count() &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adoptLockTest</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::system_clock::now();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        m.lock(); <span class="comment">//需要手动在构造unique_lock对象之前lock，使用std::adopt_lock参数的话，构造对象时实际并没有加锁，各位可以验证一下</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"adoptLockTest run time: "</span> &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="built_in">end</span> - start).count() &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryToLockTest</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m, <span class="keyword">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = chrono::system_clock::now();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m, <span class="built_in">std</span>::try_to_lock)</span></span>;</span><br><span class="line">        <span class="comment">//使用owsn_lock()来判断是否已经加锁成功，这里加锁成功则count+1</span></span><br><span class="line">        <span class="keyword">if</span> (lock.owns_lock()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"tryToLockTest run time: "</span> &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(<span class="built_in">end</span> - start).count() &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uniqueLockTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex m1, m2, m3;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count3 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(deferLockTest, <span class="built_in">std</span>::ref(m1), <span class="built_in">std</span>::ref(count1))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(deferLockTest, <span class="built_in">std</span>::ref(m1), <span class="built_in">std</span>::ref(count1))</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(adoptLockTest, <span class="built_in">std</span>::ref(m2), <span class="built_in">std</span>::ref(count2))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(adoptLockTest, <span class="built_in">std</span>::ref(m2), <span class="built_in">std</span>::ref(count2))</span></span>;</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t5</span><span class="params">(tryToLockTest, <span class="built_in">std</span>::ref(m3), <span class="built_in">std</span>::ref(count3))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t6</span><span class="params">(tryToLockTest, <span class="built_in">std</span>::ref(m3), <span class="built_in">std</span>::ref(count3))</span></span>;</span><br><span class="line">    t5.join();</span><br><span class="line">    t6.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"uniqueLockTest - result count1 : "</span> &lt;&lt; count1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"uniqueLockTest - result count2 : "</span> &lt;&lt; count2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"uniqueLockTest - result count3 : "</span> &lt;&lt; count3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了对比三者的效率，示例中添加了计时。根据我本地测试，针对此示例程序，try_to_lock比其他两位的性能差一些。这可能是存在多次轮询的原因，其他场景并不就一定差。下面是我的本地测试结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deferLockTest <span class="built_in">run</span> time: <span class="number">235</span>ms.</span><br><span class="line">deferLockTest <span class="built_in">run</span> time: <span class="number">236</span>ms.</span><br><span class="line">adoptLockTest <span class="built_in">run</span> time: <span class="number">183</span>ms.</span><br><span class="line">adoptLockTest <span class="built_in">run</span> time: <span class="number">186</span>ms.</span><br><span class="line">tryToLockTest <span class="built_in">run</span> time: <span class="number">397</span>ms.</span><br><span class="line">tryToLockTest <span class="built_in">run</span> time: <span class="number">398</span>ms.</span><br><span class="line">uniqueLockTest - result count1 : <span class="number">2000000</span></span><br><span class="line">uniqueLockTest - result count2 : <span class="number">2000000</span></span><br><span class="line">uniqueLockTest - result count3 : <span class="number">2000000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>篇幅原因，我只贴出1此测试结果，应该测试多次取平均值才有比较合理的结论。</p>
</blockquote>
<p>接下来看下mutex头文件中的两个有用的工具函数。</p>
<h5 id="两个有用的函数"><a href="#两个有用的函数" class="headerlink" title="两个有用的函数"></a>两个有用的函数</h5><p>还有2个有用的函数：</p>
<ul>
<li>std::try_lock，尝试同时对多个互斥量加锁。当某个互斥量的状态为不可用（也许是被其他线程占有了，也许是销毁了）时，会返回从0开始的索引，这个索引是表示是哪个锁开始失败的，因为这个函数接受至少两个互斥量（1个的话，没必要用这个，用mutex自带的成员变量try_lock即可）。同时如果中间某个互斥量加锁失败，则会对之前加锁成功的互斥量解锁，并立即返回失败的索引。这个也是异常安全的，当发生异常时，已经加锁的互斥量也会被解锁。</li>
<li>std::lock，同时对多个互斥量加锁，是阻塞的，直到所有的互斥量加锁成功才退出阻塞状态。使用这个函数可以有效避免很多可能发生死锁的场景，因为他保证了加锁顺序，破坏了循环等待的条件。稍后会写一个简单的例子来说明。</li>
</ul>
<p>下面是一个最简单的死锁示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothingFunc</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m1, <span class="built_in">std</span>::mutex&amp; m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(m1)</span></span>;</span><br><span class="line">    <span class="comment">//sleep 200ms，为了好复现死锁</span></span><br><span class="line">    <span class="comment">//Ps：这里很有趣，使用了本系列之前的文章中提到过的“用户自定义字面值常量”，由于这是std里的，所以可以不以下划线开头，从这里可以看到字面常量很是很有用的</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">200</span>ms);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(m2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" run nothingFun"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex m1, m2;</span><br><span class="line">    <span class="comment">//注意这里传递参数的顺序</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(nothingFunc, <span class="built_in">std</span>::ref(m1), <span class="built_in">std</span>::ref(m2))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(nothingFunc, <span class="built_in">std</span>::ref(m2), <span class="built_in">std</span>::ref(m1))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是个会发生死锁的程序（不是100%），不多解释为何会死锁了，相信各位很容易理解。要解决这个问题也很简单，即从源头出发，把17和18行的两个参数m1,m2的顺序调整成一样就行。本例还比较容易发现错误，但如果逻辑负责，这种错误是很难发现的，根据经验，这至少要经历””查log-&gt;加log复现-&gt;发现死锁-&gt;加log复现-&gt;….(中间可能有多次无效的加log)-&gt;定位的锁顺序错了-&gt;解决问题”这样一个过程，很费时费力。幸运的是，使用std::lock可以有效防止由于锁顺序导致的死锁问题，如下(仅修改nothingFunc)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothingFunc</span><span class="params">(<span class="built_in">std</span>::mutex&amp; m1, <span class="built_in">std</span>::mutex&amp; m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock(m1, m2);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(m1, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(m2, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" run nothingFun"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于本例，这样修改就肯定不会发生死锁了，因为std::lock直到对m1和m2（不一定是顺序）都加锁成功后才会从阻塞状态返回。这样就不存在t1拿着m1，等m2，t2拿着m2，等m1这样循环等待的情况，破坏了死锁发生的必要条件。</p>
<p>使用try_lock也可以解决本例的死锁问题，但需要多写个判断来判断是否对两个mutex都加锁成功。try_lock相对lock更加灵活，使用得当的话，性能会比闭锁的lock效率高。限于篇幅（其实是偷懒），我也不再写示例程序，建议各位尝试一下try_lock。</p>
<h5 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h5><p><code>&lt;mutex&gt;</code>里还有一个有趣的函数叫做call_once，之所以单独抽出来介绍，是因为要使用这个功能，还需要使用另一个与之配套的类std::once_flag。call_once和std::once_flag组合使用可以实现这样的效果：使某个任务（可以是函数或者其他可调用对象）在多线程环境下<strong>保证</strong>只执行一次！常常用于多线程环境下的初始化场景。</p>
<p>下面拿单例模式举例，利用call_once可以实现线程安全的单例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(m_instance_created_flag,[]()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"call once"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_instance.reset(<span class="keyword">new</span> Singleton());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; m_instance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::once_flag m_instance_created_flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag Singleton::m_instance_created_flag;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; Singleton::m_instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callOnceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(&amp;Singleton::getInstance)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(&amp;Singleton::getInstance)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(&amp;Singleton::getInstance)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(&amp;Singleton::getInstance)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以发现在多线程环境下”call once”只打印了一次，即只构造了一次SIngleton对象，是符合单例模式的。</p>
<blockquote>
<p>Ps: 实现线程安全的单例模式还有更简单的方法，即利用局部static只会在第一次执行时初始化的原理，这样的单例更简单。</p>
</blockquote>
<blockquote>
<p>PPs: 细心的朋友可能会注意到，这里的单例是用shared_ptr包装的，这是因为如果使用裸指针的话，即使是单例，也会有裸指针的那些问题。既然用起了C++11，就尽量避免使用裸指针吧。另外，这里不一定要使用shared_ptr，使用unique_prt也是可以的，但要注意的是，不能在函数中返回unique_ptr，因为unique_ptr是不能被拷贝的，可以返回他的引用，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(m_instance_created_flag,[]()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"call once"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_instance.reset(<span class="keyword">new</span> Singleton());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> *m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; m_instance;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h4><p>条件变量也是一种线程同步的手段，适合用在符合生产者消费者模型的场景，消费者需要等待生产者完成任务才去执行消费者自己的逻辑。如果仅使用互斥量，也可以实现这个目的，即使用超时轮询的方式，但这样会导致一些性能浪费，甚至极限场景下某些线程会一直无法加锁成功。而条件变量是基于事件通知的，当某个条件达成的时候才会唤醒其他线程，继续执行安排好的任务。这种方式既没有让CPU空转，其工作方式也很好理解，会使用之后基本不会出现太大问题。</p>
<p><code>&lt;condition_variable&gt;</code>头文件提供了一些类和函数来支持使用条件变量：</p>
<ul>
<li>condition_variable类，需要结合std::unique_lock来使用。</li>
<li>condition_variable_any类，并不强制要求使用std::unique_lock，实际中很少看到有使用。</li>
<li>cv_status枚举类，这是一个scoped enum，用来表示条件变量是否是因为超时导致的从阻塞状态醒来。只有timeout和no_timeout两个枚举量。</li>
<li>notify_all_at_thread_exit函数，当线程退出时，唤醒所有在这个条件变量上等待的线程。</li>
</ul>
<p>我们重点介绍condition_variable类，其他的在示例程序中用到的话会再简单介绍。下面是一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="built_in">std</span>::condition_variable&amp; cv, <span class="built_in">std</span>::mutex&amp; m, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">bool</span>&amp; isStop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//注意这里是单独的一个作用域，因为在notify之前，需要先unlock，防止出现另一个线程起来了，无法lock的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">            q.push(i);</span><br><span class="line">        	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"produce : "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//这里是标记生产结束了，同样，注意unlock的时机</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        isStop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里使用notify_all很重要，在文中细说</span></span><br><span class="line">    cv.notify_all();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="built_in">std</span>::condition_variable&amp; cv, <span class="built_in">std</span>::mutex&amp; m, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">bool</span>&amp; isStop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">-1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">            <span class="comment">//wait的第二个参数是一个函数对象，这里用lambda来写了。线程只有在被唤醒且该条件成立的情况下才会真正从阻塞状态返回</span></span><br><span class="line">            cv.wait(lock, [&amp;]()&#123;</span><br><span class="line">                <span class="comment">//这个顺序也要注意一下，||是短路的</span></span><br><span class="line">                <span class="keyword">return</span> isStop || !q.empty();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread- "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"wakeup!!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//判断退出条件</span></span><br><span class="line">            <span class="keyword">if</span> (isStop &amp;&amp; q.empty()) <span class="keyword">return</span>;</span><br><span class="line">            val = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">        	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread- "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" consume "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conditionVariableTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable cv;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">bool</span> isStop;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(produce, <span class="built_in">std</span>::ref(cv), <span class="built_in">std</span>::ref(m), <span class="built_in">std</span>::ref(q), <span class="built_in">std</span>::ref(isStop))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consume, <span class="built_in">std</span>::ref(cv), <span class="built_in">std</span>::ref(m), <span class="built_in">std</span>::ref(q), <span class="built_in">std</span>::ref(isStop))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(consume, <span class="built_in">std</span>::ref(cv), <span class="built_in">std</span>::ref(m), <span class="built_in">std</span>::ref(q), <span class="built_in">std</span>::ref(isStop))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于示例的一部分说明已经在注释中写了。这里主要说一下produce函数最后的那个notify_all调用，各位看代码的时候可能会疑惑这里为什么是notify_all？能不能用notify_one呢？先说一下两者的区别：</p>
<ul>
<li>notify_one唤醒某一个在wait的线程，该线程被唤醒后会马上去尝试获得锁，所以不存在锁竞争。</li>
<li>notify_all唤醒所有在wait的线程，会发生锁竞争。剩下没有拿到锁的线程会继续阻塞，<strong>不过这次阻塞不是阻塞在条件变量上，而是在互斥量上，这很重要。</strong></li>
</ul>
<p>基于上述描述，得到如下结论：</p>
<ul>
<li>线程要从wait状态返回是需要满足两个条件的：<strong>被notify通知到以及能成功对互斥量重新加锁。</strong>注意，这个结论非常重要。</li>
</ul>
<p>基于结论，存在如下两种情况：</p>
<ol>
<li>线程收到了notify，并且条件判断ok，然后去尝试获取互斥量，发现获取不到，那么该线程会继续在这个互斥量上阻塞，等待其他线程释放互斥锁。</li>
<li>线程收到了notify，然后去加锁，并且加锁成功，那么会直接从wait状态中返回。</li>
</ol>
<p>为了保证所有的线程都能正常消费完毕且退出，需要使用notify_all来向所有线程发送信号，之后他们只需要去争夺锁资源就可以了，而争夺锁资源这个事与条件变量并没有必然的联系，不会收到条件变量的影响。所以最终所有线程都能正常退出。</p>
<p>条件变量是一个有力的工具，但还需要注意要搭配判断状态的条件来使用，即wait之后的那个条件。否则可能会出现线程错过了notify的情况，即<strong>notify在前，wait之后的情况。</strong></p>
<blockquote>
<p>抛一个问题留给各位，各位可以尝试使用notify_one替换notify_all，然后多开几个线程，多执行几次程序。看看会有什么问题，问题的原因又是什么。</p>
</blockquote>
<h2 id="future"><a href="#future" class="headerlink" title="future"></a>future</h2><p><code>&lt;future&gt;</code>这个头文件提供了支持用户完成future/promise模式异步编程的一系列类和函数。所谓的异步，是相对于同步来说的，同步就是要执行一个任务，必须等待该任务的结果返回，当前线程才能继续执行剩下的逻辑，而异步则将任务丢给另一个线程去执行，当前线程无需等待任务结果返回。注意不要混淆这里所说的<strong>同步</strong>和上面提到的使用mutex，condition等线程同步手段中的<strong>同步</strong>，线程同步那是多线程环境下保护共享变量的手段，而这里所说的同步指的是一种编程模型。</p>
<blockquote>
<p>关于异步编程更加详细的介绍，各位可以自行查阅资料，网上有很多。</p>
</blockquote>
<p>下面是<code>&lt;future&gt;</code>头文件提供的一些常用的类和函数：</p>
<ul>
<li>promise，保存值或者异常，一般用于保存任务的结果，需要和future关联使用。每个promise都有一个共享状态，用于表示promise的结果是个什么状态，这个共享状态和future关联，这就是共享的含义，状态有如下3种：<ul>
<li>make ready，即promise已经存储了结果或者异常，其他阻塞在与promise关联的future的线程会被唤醒。</li>
<li>release，promise释放了共享状态。</li>
<li>abandon，promise存储了std::future_errc::broken_promise这个值。abandon状态之后会成为make ready状态，然后将其释放，即release。</li>
</ul>
</li>
<li>future和shared_future，用来获取异步任务的结果的对象，这里先可以简单理解为一个句柄（不严谨，仅为了说明其作用），可以直接调用构造函数构造，但没有什么作用的。一般都是通过promise，async, packaged_task来创建，并与之关联。shared_future相对于future来说，多了可以拷贝的能力，多个shared_future可以共享同一个共享状态，并且都可以获得其对应的值。</li>
<li>packaged_task，将可调用对象打包在一起成为一个对象，并且可以异步的获取对应的可调用对象返回的结果，说白了，就是std::function + 异步。后续使用到的时候就可以理解了。</li>
<li>async，很直白，以异步的方式执行任务，调用后返回一个future，用于后续获取任务的结果。使用async比使用promise+future更加简单，也更加直观。调用std::async的时候可以指定其创建线程的策略，如果不指定策略则系统会自行决定是否需要立刻创建一个线程。至于有哪些策略，各位可自行查阅文档，不再赘述。</li>
</ul>
<p>下面是使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">calcSum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        res += i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendResult</span><span class="params">(<span class="keyword">long</span> result, <span class="built_in">std</span>::<span class="built_in">string</span> message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asyncTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用packaged_task封装函数，这个task可以返回一个future，用于后续获取结果</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">long</span><span class="params">(<span class="keyword">void</span>)</span>&gt; <span class="title">task</span><span class="params">(<span class="built_in">std</span>::bind(calcSum, <span class="number">1</span>, <span class="number">1000</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">long</span>&gt; f1 = task.get_future();</span><br><span class="line">    <span class="comment">//注意，packged_task的拷贝构造是被设置为delete的，所以这里传递，只能使用std::move</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(task))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">long</span>&gt; f2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, calcSum, <span class="number">1001</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">long</span>&gt; f3 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, calcSum, <span class="number">2001</span>, <span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">long</span>&gt; f4 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, calcSum, <span class="number">3001</span>, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sleepCount = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sleepCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main thread still do something..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">500</span>ms);</span><br><span class="line">        <span class="comment">//这里可以先发送一个初步结果给需要的用户，然后主线程也还可以接受其他计算请求</span></span><br><span class="line">        sendResult(result, <span class="string">"result is still calculating, please wait...."</span>);</span><br><span class="line">        sleepCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += f1.<span class="built_in">get</span>();</span><br><span class="line">    result += f2.<span class="built_in">get</span>();</span><br><span class="line">    result += f3.<span class="built_in">get</span>();</span><br><span class="line">    result += f4.<span class="built_in">get</span>();</span><br><span class="line">    sendResult(result, <span class="string">"async calc sum (1~4000) == "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例很简单，就是将1～4000的累加拆分成4个任务，然后用4个线程去作计算，最后去获取结果。在创建线程到最后去获取结果的过程中，主线程是不会阻塞的，可以继续执行后面的逻辑。这时候，各位可能会有疑问了，这里直接用4个普通线程去做，主线程也可以不阻塞啊，那这个异步的好处在哪？</p>
<p>首先明确，多线程和所谓的同步或者异步是两个不同维度的概念，多线程是可以实现异步的一种手段，多线程和异步并不是两种不同的编程模型。所以这里使用4个普通线程去作这个事，是完全可以的，那其实也是实现了异步模型，两者并不冲突。这里使用C++11提供的新API只是可以更方便快捷的编写异步程序，例如可以通过future方便的获取返回值，<strong>只要你能拿到future，几乎可以在任何地方去拿结果</strong>，这是很有用的，在多个模块之间传递数据时可以减少需要考虑的事，而用多个普通std::thread创建的线程，则需要更多的考虑如何拿到结果。</p>
<p>这个例子没有直接使用到promise（其实是有的，只是封装了），为了内容完整，下面看一个使用promise的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promiseTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; f = p.get_future();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">([&amp;p]()&#123; p.set_value(<span class="string">"Hello, Guys!"</span>); &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>(); <span class="comment">//detach，否则会core dump，因为资源没有释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//wait会阻塞</span></span><br><span class="line">    f.wait();</span><br><span class="line">    <span class="comment">//这里调用get就不会阻塞了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"message : "</span> &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，其实promise就是线程间同步的一种手段，set_value就是往共享状态里设置结果，如果没有设置结果的话，f.wait()或者f.get()会一直阻塞。</p>
<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>最后再简单介绍一下<code>&lt;atomic&gt;</code>，这个头文件包含很多原子类型，所谓原子类型，就是具有原子性的类型（有点废话了），对这些类型定义的变量进行操作都是原子操作，即是线程安全的操作，所谓原子操作就是一系列操作不可被其他线程打断。 例如对int类型+1，编译后的指令会是先取数，对数据+1，再写回这3个操作，使用原子类型的话，这3个操作会是连续的，不会被其他线程打断的，所以能保证线程安全。</p>
<p>原子操作的另一个优势就是他是无锁的，上面介绍mutex的有介绍过，mutex在多线程同步的时候会存在一定的性能消耗，主要消耗在锁竞争上，而原子操作因为不存在锁，所以原子类型的性能会高于互斥锁。各位可能会问，不用锁的话，原子操作是怎么保证操作“不会被其他线程打断”的？其实这个是有CPU保证的，CPU的指令集中是有原子指令的，编译器编译后可以生成对应的指令，进而让程序使用CPU提供的原子指令完成原子操作。</p>
<p><code>&lt;atomic&gt;</code>里最重要和最常用的一个类就是atomic类，这是一个模板类，模板参数要求是trivial且可拷贝的，例如int,bool,char，指针以及自定义的满足trivial且可拷贝条件的自定义类型，一般还是使用几个基础类型多一些（具体可参考<a href="https://stackoverflow.com/questions/16355425/c-atomic-with-non-trivial-type" target="_blank" rel="noopener">C++ atomic with non-trivial type?</a>）atomic有两个重要的函数，load和store，分别对应原子读和原子写，也提供了特殊的自增，自简等特殊的操作符重载。同时为了使用方便，头文件中还提供了atomic_bool，atomic_char这种别名给用户使用，具体有哪些，各位可自行查阅文档，不再赘述。下面是一个简单的使用atomic的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCount1</span><span class="params">(<span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&amp; count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomicTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(addCount1, <span class="built_in">std</span>::ref(count)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result Count = "</span> &lt;&lt; count.load() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，不多解释了。</p>
<h4 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h4><p>C++11也把thread_local纳入C++标准里了，thread_local在C++11里是一个关键字，用来修饰变量是所谓的线程本地变量，即多个线程访问该变量，都是在访问线程本地的副本，其原理就类似于一个map，key是线程id，value就是值，当线程访问该变量时，会先用线程id去获取该变量的副本，然后对其进行操作，所以thread_local是天然线程安全的。比较简单，不多介绍了，直接看一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boringFunc3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boringFunc4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boringFunc3();</span><br><span class="line">    boringFunc3();</span><br><span class="line">    boringFunc3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        threads.emplace_back(boringFunc4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行你会发现，每个线程对待cnt都是独立的，不会收到其他线程的影响，对于本例来说，8个线程最终都会答应cnt值是3。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了多线程相关的几个新头文件，C++11对多线程的支持还是比较丰富的，提供了很多方便使用的API，例如可跨平台的std::thread，线程同步手段mutex，条件变量，异步future/promise, async等。由于篇幅限制，我们没有相信列出各个类提供的所有API，只列出了常用的几个，各位可以自行查阅，有些虽然不常用，但也很有用。</p>
<p>多线程编程能提高程序执行效率，但相比单线程编程来说，需要考虑的事情更多，更复杂，例如需要识别可能存在共享变量并发修改，然后选用适合的机制去保护共享变量，又例如即使使用了互斥量来保护共享变量，又如何防止死锁，C++11提供了多种方法来防止死锁，正文有提到。</p>
<p>最后，借用stackoverflow上的大佬的一句话结尾：Multithreaded programming is hard，respect it!</p>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">atomic operations library</a></li>
<li><input checked="" disabled="" type="checkbox"> smart pointer</li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">std::initializer_list</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Stateful_and_stateless_allocators" target="_blank" rel="noopener">stateful</a> and <a href="https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor" target="_blank" rel="noopener">scoped</a> allocators</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/container/forward_list" target="_blank" rel="noopener">std::forward_list</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/chrono" target="_blank" rel="noopener">chrono library</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/numeric/ratio" target="_blank" rel="noopener">ratio library</a></li>
<li><input disabled="" type="checkbox"> new <a href="https://en.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">algorithms</a>:<ul>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::all_of</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::any_of</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of" target="_blank" rel="noopener">std::none_of</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/find" target="_blank" rel="noopener">std::find_if_not</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/copy_n" target="_blank" rel="noopener">std::copy_n</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/move" target="_blank" rel="noopener">std::move</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/move_backward" target="_blank" rel="noopener">std::move_backward</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle" target="_blank" rel="noopener">std::random_shuffle</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle" target="_blank" rel="noopener">std::shuffle</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned" target="_blank" rel="noopener">std::is_partitioned</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/partition_copy" target="_blank" rel="noopener">std::partition_copy</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/partition_point" target="_blank" rel="noopener">std::partition_point</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted" target="_blank" rel="noopener">std::is_sorted</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted_until" target="_blank" rel="noopener">std::is_sorted_until</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_heap" target="_blank" rel="noopener">std::is_heap</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/is_heap_until" target="_blank" rel="noopener">std::is_heap_until</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/minmax" target="_blank" rel="noopener">std::minmax</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/minmax_element" target="_blank" rel="noopener">std::minmax_element</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/is_permutation" target="_blank" rel="noopener">std::is_permutation</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/algorithm/iota" target="_blank" rel="noopener">std::iota</a>,</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy_n" target="_blank" rel="noopener">std::uninitialized_copy_n</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/locale#Locale-independent_unicode_conversion_facets" target="_blank" rel="noopener">Unicode conversion facets</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">thread library</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/utility/functional/function" target="_blank" rel="noopener">std::function</a></li>
<li><input checked="" disabled="" type="checkbox"> std::bind</li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/error/exception_ptr" target="_blank" rel="noopener">std::exception_ptr</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/error/error_code" target="_blank" rel="noopener">std::error_code</a> and <a href="https://en.cppreference.com/w/cpp/error/error_condition" target="_blank" rel="noopener">std::error_condition</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">iterator</a> improvements:<ul>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/begin" target="_blank" rel="noopener">std::begin</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/end" target="_blank" rel="noopener">std::end</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/next" target="_blank" rel="noopener">std::next</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.cppreference.com/w/cpp/iterator/prev" target="_blank" rel="noopener">std::prev</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Unicode conversion functions</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>