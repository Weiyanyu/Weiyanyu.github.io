<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeonon&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-18T06:29:27.564Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yeonon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Activity 生命周期总结</title>
    <link href="http://yoursite.com/2017/07/18/android%20activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/07/18/android activity 生命周期/</id>
    <published>2017-07-18T04:48:27.418Z</published>
    <updated>2017-07-18T06:29:27.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Activity简介"><a href="#Activity简介" class="headerlink" title="Activity简介"></a>Activity简介</h3><p>Activity（活动） 是 Android 四大组件之一，也是核心组件。负责将界面展示给用户，并可以与用户有一定的交互，例如用户输入，用户点击按钮等等，简单来说的话就是用户能直接看到的就是Activity。</p>
<a id="more"></a>
<h3 id="Activity正常生命周期"><a href="#Activity正常生命周期" class="headerlink" title="Activity正常生命周期"></a>Activity正常生命周期</h3><blockquote>
<p>注意标题中的正常字眼，这意味着Activity的生命周期并不单一，具体的还有异常情况下的生命周期，将在后面讲到。</p>
</blockquote>
<p>组件的生命周期指的就是组件从被创建到销毁整个过程中所要经历的阶段，并呈现一定的周期性，先看一张图。</p>
<p><img src="/images/activity_lifecycle.png" alt=""></p>
<blockquote>
<p>图片来源：android 开发者官方文档</p>
</blockquote>
<p>有点经验的同学理解上图应该没什么压力（是在不明白的同学可以看看其他文章，都写得很好，在此我就不再赘述了），值得注意的一个细节是当要启动另一个活动的时候，当前活动会经历onPause() -&gt; onStop()，但是是新的活动的onCreate() (如果有必要的话) -&gt; onStart() -&gt; onResume() 路径先执行还是onPause() 先执行呢？</p>
<p>我们先重写这些回调方法，在方法中打印一些日志作为标记（代码我就不贴了，很简单的一段代码）</p>
<p><img src="/images/activity_lifecycle_log.png" alt=""></p>
<p>如图，我们看到，onPause() 是先执行的，我们可以尝试从源码找找为什么会这样。</p>
<p><img src="/images/Activity_stack.png" alt=""></p>
<p>这是ActivityStack.java 里resumeTopActivityInnerLocked() 方法里的一段代码，从这段代码中我们可以看到，在启动另一个活动之前，是需要等待当前活动的pause方法执行完毕的，我们还看到里面调用的方法有startPausingLocked()，这个Locked是否使用了线程相关的技术呢？比如互斥锁？经过查找资料，可以知道启动活动的时候是经历很复杂的过程的，当中也涉及到了线程，具体内容因笔者水平实在有限，无法讲述，有兴趣的朋友可以继续研读源码，寻找答案。</p>
<p><strong>Ps:</strong> 从上面我们知道了onPause执行完毕才会执行新的Activity，此时如果我们在onPause()方法中做了一些耗时较大的操作，就有可能导致UI阻塞等等情况，所以不建议在onPause里做耗时操作，如果必须要做一些操作的话，可以放入onStop方法中，这样就不会影响新活动的创建与执行了。</p>
<h3 id="Activity异常生命周期"><a href="#Activity异常生命周期" class="headerlink" title="Activity异常生命周期"></a>Activity异常生命周期</h3><p>异常生命周期主要有两种情况：</p>
<ol>
<li>资源相关的系统配置发生改变导致Activity被杀死被重建</li>
</ol>
<p>比如当手机屏幕旋转时，Activity会被杀死，并且会先调用onSaveInstanceState()回调方法（该方法可以保持程序崩溃前的状态），然后立马调用onCreate() -&gt; onRestoreInstanceState() 以恢复之前的状态。在onCreate方法中有一个Bundle类型的参数保存着原先的状态信息，在正常启动的情况下，这个参数是null，在重建活动后，该参数就可以使用了。</p>
<blockquote>
<p>关于生命周期中的其他方法的执行顺序，各位可以自行打日志的方式查看，不再赘述了。</p>
</blockquote>
<ol>
<li>资源内存不足导致低优先级的Activity被杀死</li>
</ol>
<p>这种情况不难理解，在僧多粥少的年代，有颜值的，有能力的男人（优先级高）才能找到对象嘛。（不过我们可以自己New一个，233333）。Activity优先级大致可以分为三种：</p>
<ul>
<li>前台Activity，与用户交互的活动，优先级最高</li>
<li>可见但非前台Activity，经历onPause方法但为经历onStop方法的Activity，优先级次之</li>
<li>后台Activity， 经历了onStop方法的Activity，优先级最低</li>
</ul>
<p>与第一种情况相似，这种情况也有保存 -&gt; 恢复的过程。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>理解Activity生命周期是理解Activity的第一站，笔者本人目前也刚刚接触android不久， 水平实在有限，如有不正确的地方，欢迎指正，不胜感激。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Activity简介&quot;&gt;&lt;a href=&quot;#Activity简介&quot; class=&quot;headerlink&quot; title=&quot;Activity简介&quot;&gt;&lt;/a&gt;Activity简介&lt;/h3&gt;&lt;p&gt;Activity（活动） 是 Android 四大组件之一，也是核心组件。负责将界面展示给用户，并可以与用户有一定的交互，例如用户输入，用户点击按钮等等，简单来说的话就是用户能直接看到的就是Activity。&lt;/p&gt;
    
    </summary>
    
      <category term="Android 总结" scheme="http://yoursite.com/categories/Android-%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一个搜索招聘信息的工具</title>
    <link href="http://yoursite.com/2017/07/18/%E4%B8%80%E4%B8%AA%E6%9C%89%E7%82%B9%E7%94%A8%E5%A4%84%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2017/07/18/一个有点用处的小工具/</id>
    <published>2017-07-18T04:38:22.096Z</published>
    <updated>2017-06-01T08:59:29.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-功能（目前是开发阶段，以下功能仅实现部分）"><a href="#一-功能（目前是开发阶段，以下功能仅实现部分）" class="headerlink" title="一. 功能（目前是开发阶段，以下功能仅实现部分）"></a>一. 功能（目前是开发阶段，以下功能仅实现部分）</h3><ol>
<li>根据提示输入关键字搜索相关职位信息，并将信息部分呈现出来。</li>
<li>程序根据搜索得到的信息绘制成图像，供用户观看或使用。</li>
<li>提供每个职位招聘信息的URL，用户可点击URL进入网页，查看招聘的详细信息。</li>
<li>程序根据得到的数据自动的进行一定的分析，并展现给用户（难度较大，目前不知道如何做）</li>
</ol>
<blockquote>
<p><strong>Ps</strong>: 程序应该是一个图形用户界面，使用pyQt5</p>
</blockquote>
<a id="more"></a>
<h3 id="二-特性"><a href="#二-特性" class="headerlink" title="二. 特性"></a>二. 特性</h3><ol>
<li>使用多线程爬虫（可能有问题，正在想办法解决），多态的方式组织爬虫类，可以按需更改爬虫网站，只需重写少数几个方法即可</li>
<li>使用python数据分析库实现简单的数据分析</li>
<li>部分文件存储成CSV格式，用户可自行提取（文件在/resource 里）并导入到文档处理软件（例如<br>excel）</li>
<li>图片也采用直接存储到文件里的方式，同样，用户可以使用</li>
</ol>
<h3 id="三-使用的技术（或框架）"><a href="#三-使用的技术（或框架）" class="headerlink" title="三. 使用的技术（或框架）"></a>三. 使用的技术（或框架）</h3><h4 id="语言："><a href="#语言：" class="headerlink" title="语言："></a>语言：</h4><ul>
<li>python</li>
</ul>
<h4 id="类库"><a href="#类库" class="headerlink" title="类库:"></a>类库:</h4><ul>
<li>requests (用于爬虫)</li>
<li>BeautifulSoup (用于提取数据)</li>
<li>threading (用于支持多线程爬虫)</li>
<li>matplotlib （用于绘制并生成图像）</li>
<li>pandas (用于数据处理，使matplotlib方便绘图)</li>
</ul>
<h4 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h4><ul>
<li>pyQt5 (著名的C++框架Qt 的python版本吧,用于GUI部分)</li>
</ul>
<h3 id="四-操作演示"><a href="#四-操作演示" class="headerlink" title="四. 操作演示"></a>四. 操作演示</h3><blockquote>
<p>请移步我的github 查看</p>
</blockquote>
<h3 id="五-未来展望"><a href="#五-未来展望" class="headerlink" title="五. 未来展望"></a>五. 未来展望</h3><p>这是第一个版本，目前功能较少，界面比较难看（哎。。。UI麻烦啊）,但是核心部分已经基本完成（爬虫，基本界面，生成数据分析图），且项目结构应该问题不大,未来应该只需要往上增加功能就行了。</p>
<blockquote>
<p>连续写了4天，快40个小时，肝不行了，先暂停吧，以后再写。</p>
</blockquote>
<p><strong>Ps</strong> : 寻求同学共同完成，有兴趣的同学随时联系，在此谢过。</p>
<blockquote>
<p>下一篇文章，将总结此次开发的一些细节</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-功能（目前是开发阶段，以下功能仅实现部分）&quot;&gt;&lt;a href=&quot;#一-功能（目前是开发阶段，以下功能仅实现部分）&quot; class=&quot;headerlink&quot; title=&quot;一. 功能（目前是开发阶段，以下功能仅实现部分）&quot;&gt;&lt;/a&gt;一. 功能（目前是开发阶段，以下功能仅实现部分）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;根据提示输入关键字搜索相关职位信息，并将信息部分呈现出来。&lt;/li&gt;
&lt;li&gt;程序根据搜索得到的信息绘制成图像，供用户观看或使用。&lt;/li&gt;
&lt;li&gt;提供每个职位招聘信息的URL，用户可点击URL进入网页，查看招聘的详细信息。&lt;/li&gt;
&lt;li&gt;程序根据得到的数据自动的进行一定的分析，并展现给用户（难度较大，目前不知道如何做）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ps&lt;/strong&gt;: 程序应该是一个图形用户界面，使用pyQt5&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 70. Climbing Stairs</title>
    <link href="http://yoursite.com/2017/07/18/70.%20Climbing%20Stairs/"/>
    <id>http://yoursite.com/2017/07/18/70. Climbing Stairs/</id>
    <published>2017-07-18T04:38:22.095Z</published>
    <updated>2017-06-30T12:50:39.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given n will be a positive integer.</p>
<a id="more"></a>
<h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><p>暴力枚举，累加所有可能的情况即可。优点是简单粗暴，缺点就是复杂度是指数级别的，数据量稍微大一点就难以得出结果了。</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>先上代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = a + b;</div><div class="line">            a = b;</div><div class="line">            b = temp;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用<strong>动态规划</strong>的思想来解决，先找到最优子结构，注意最优子结构并不一定只有一个，例如这里我们不难得出我们要算出climbStairs(10)，可以先算出climbStairs(9) 和 climbStairs(8)（至于如何得出的，可以网上搜索一下，很容易可以搜到，在此不再赘述），这里climbStairs(9),climbStairs(8)就是climbStairs(10)的最优子结构，climbStairs(n) = climbStairs(n-1) + climbStairs(n-2) 就是状态转移方程，climbStairs(1) , climbStairs(0) 就是这种条件下的边界。确定了以上三要素，就可以使用动态规划的思想来解决问题了。</p>
<p>在上面，我们可以看到<strong>动态转移方程: climbStairs(n-1) + climbStairs(n-2)</strong></p>
<p>是不是有点想斐波那契数列的方程，斐波那契数列是递推，显然这里也是递推，这似乎是巧合，但是经过查找资料得出一个结论：</p>
<p><strong>动态规划其实就是递推</strong>. 更多关于动态规划的知识，各位可以网上搜索资料，或者看看算法导论，里面有专门的一章内容介绍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Given n will be a positive integer.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 575. Distribute Candies</title>
    <link href="http://yoursite.com/2017/07/18/575.Distribute_Candies/"/>
    <id>http://yoursite.com/2017/07/18/575.Distribute_Candies/</id>
    <published>2017-07-18T04:38:22.094Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: candies = [1,1,2,2,3,3]<br>Output: 3<br>Explanation:<br>There are three different kinds of candies (1, 2 and 3), and two candies for each kind.<br>Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.<br>The sister has three different kinds of candies. </p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashtable;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; candies.size(); ++i) &#123;</div><div class="line">            hashtable.insert(candies[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> eachSize = candies.size() / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> kindSize = hashtable.size();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> kindSize &gt; eachSize ? eachSize : kindSize;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用哈希表来存储种类，经过观察，找到规律发现当种类不足总数的一半时，结果是种类数，当种类超过总数一半时，结果就是总数一半（这里很自然，因为两人是平分的，种类数不可能超过分到的数目），这样就完事了，很简单。这里的时间复杂度是O(N)（循环的时间），空间复杂度也是O(N) （存表需要的线性空间）。下面来看第二种方法。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</div><div class="line">        <span class="keyword">size_t</span> kinds = <span class="number">0</span>;</div><div class="line">        sort(candies.begin(), candies.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.size(); i++) &#123;</div><div class="line">            kinds += i == <span class="number">0</span> || candies[i] != candies[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min(kinds, candies.size() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种方式为方便找到种类数，先进行排序，处理结果的方式同第一种方法，核心就是要找到种类数。这里时间复杂度是O(NlogN) (sort排序花费时间占大头，但是这只是平均时间复杂度，因为C++ 的sort 会根据容器大小来决定使用哪种排序，并不仅仅是快排)，空间复杂度是O(1)，并没有占用额外的空间。</p>
<p><strong>Note:</strong> 以上两种方式都很好，主要是看应用场景，如果空间较紧张，哈希表的方式显然不合适，因为数据大的话很有可能会生成庞大的哈希表，这时候就应采用第二种方式了，用时间换空间。反之，对性能要求较高，而空间不是那么紧张的话，就可以采用第一种方式了。当然，还有第三种情况就是对性能要求较高，而空间也相对紧张（比如一些嵌入式应用），这时候就要看侧重点了，得具体问题做详细分析。</p>
<blockquote>
<p>这题显然是一道很简单的题目，但是写了不少，原因是想说明再简单的问题，也会因为使用数据结构或算法不当而导致BUG，亦不可因为简单而掉以轻心。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 572. Subtree of Another Tree</title>
    <link href="http://yoursite.com/2017/07/18/572.%20Subtree%20of%20Another%20Tree/"/>
    <id>http://yoursite.com/2017/07/18/572. Subtree of Another Tree/</id>
    <published>2017-07-18T04:38:22.093Z</published>
    <updated>2017-06-24T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<a id="more"></a>
<p>Example 1:<br>Given tree s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  4   5</div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<p>Given tree t:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  4 </div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<h3 id="第一种方法（暴力直接的方法）"><a href="#第一种方法（暴力直接的方法）" class="headerlink" title="第一种方法（暴力直接的方法）"></a>第一种方法（暴力直接的方法）</h3><p>代码不少，在这里我就不贴了，应该是没什么问题的。思路如下：</p>
<p>可以先遍历两颗树，将节点存入两个个vector里，确定谁可能是子树（Leetcode的题目已明确t是子树，这步在此题中就不是必要的了）。然后遍历非子树（直接遍历数组即可），直到找到和子树的根节点相同的节点，这时候就直接将子树挂载到找到的节点的父节点（这里查找方法可能有点麻烦，但是是可以实现的，注意不能直接对当前字节查询，因为我们需要知道父节点），然后再遍历新的树，最后和刚开始得到的非字树做比较，若完全相同，则返回True，否侧返回False。</p>
<p>这个方法着实麻烦，而且效率不高（虽然复杂度是O(N)，但是遍历次数较多）</p>
<h3 id="第二种方法-Leetcode网友分享"><a href="#第二种方法-Leetcode网友分享" class="headerlink" title="第二种方法 (Leetcode网友分享)"></a>第二种方法 (Leetcode网友分享)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; nodes;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        getDepth(s, getDepth(t, <span class="number">-1</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : nodes) &#123;</div><div class="line">            <span class="keyword">if</span> (isSame(n, t))</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *node, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> depth = max(getDepth(node-&gt;left, d), getDepth(node-&gt;right, d)) + <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (depth == d)</div><div class="line">            nodes.push_back(node);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> depth;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *a, TreeNode *b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (!a || !b || a-&gt;val != b-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> isSame(a-&gt;left, b-&gt;left) &amp;&amp; isSame(a-&gt;right, b-&gt;right);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法就是先获取子树的深度，然后再去找非子树的深度，在找的过程中可能会碰到和子树深度相同的树（即非子树的子树），找到之后将节点放入数组中，最后遍历数组，拿数组中元素（节点）与子树递归比较即可得出结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 566 Reshape the Matrix</title>
    <link href="http://yoursite.com/2017/07/18/566.Reshape_the_Matrix/"/>
    <id>http://yoursite.com/2017/07/18/566.Reshape_the_Matrix/</id>
    <published>2017-07-18T04:38:22.091Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br>Output:<br>[[1,2,3,4]]<br>Explanation:<br>The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>代码就不贴了，直接暴力解决，写两个for循环就行，时间复杂度应该是O(n²)</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</div><div class="line">        <span class="keyword">int</span> row = nums.size();</div><div class="line">        <span class="keyword">int</span> col = nums[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> cap = row * col;</div><div class="line">        <span class="keyword">if</span> (r * c != cap) <span class="keyword">return</span> nums;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c,<span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cap; ++i) &#123;</div><div class="line">            res[i / c][i % c] = nums[i / col][i % col];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>很好的一种方法（我第一次遇到，真是想不到这种方法，这是参考Leetcode网友的答案）.<br>原理是按照先行后列的方式读取原矩阵的元素，然后放置到新数组中相应的位置。<br>放置的方式也是按照先行后列的方式放置，所以有了这行代码 : <strong>res[i / c][i % c] = nums[i / col][i % col];</strong>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.&lt;/p&gt;
&lt;p&gt;You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.&lt;/p&gt;
&lt;p&gt;The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.&lt;/p&gt;
&lt;p&gt;If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 561. Array Parition I</title>
    <link href="http://yoursite.com/2017/07/18/561.Array_Partition_I/"/>
    <id>http://yoursite.com/2017/07/18/561.Array_Partition_I/</id>
    <published>2017-07-18T04:38:22.090Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: [1,4,3,2]</p>
<p>Output: 4<br>Explanation: n is 2, and the maximum sum of pairs is 4.</p>
<h3 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = num;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</div><div class="line">            temp /= <span class="number">2</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        temp = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            num = num ^ temp;</div><div class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路是先算出该整数的最大有效位数，通过不断除以2，计数直至该整数为0为止。然后就是核心部分了，使用异或运算，初始时使用1与之异或，然后左移变量(即代码中的temp)。最终即可得到答案。</p>
<p>这里还是举个例子吧，便于理解。比如要求的整数是5（二进制101，下同），我们先确定最大有效位数（即3），然后先做 1 ^ 5 (结果是100，即4)，接着1左移1位（010），注意此时整数已经被赋值为4了，紧接着4(100) 与 2 (010) 再异或，010 再左移，如此循环即可，最终返回num.</p>
<p><strong>Ps</strong>: 这里有更方便的方法，用bitset的 flip() 方法，直接翻转。最后再转换成整形即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 557. Reverse Words in a String III</title>
    <link href="http://yoursite.com/2017/07/18/557.Reverse_Words_in_String_III/"/>
    <id>http://yoursite.com/2017/07/18/557.Reverse_Words_in_String_III/</id>
    <published>2017-07-18T04:38:22.088Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</div><div class="line">    	<span class="built_in">string</span> temp;</div><div class="line">    	<span class="built_in">string</span> res;</div><div class="line">    	<span class="keyword">while</span> (ss &gt;&gt; temp) &#123;</div><div class="line">    		reverse(temp.begin(), temp.end());</div><div class="line">    		res = res + temp + <span class="string">" "</span>;</div><div class="line">    	&#125;</div><div class="line">    	res.erase(res.end() - <span class="number">1</span>, res.end());</div><div class="line">    	<span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是第一种方法，使用stringstream类来方便分割字符串（空格分割），然后对每一个单词做翻转就行了。（注意最后的空格）</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">size_t</span> front = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(i == s.length() || s[i] == <span class="string">' '</span>)&#123;</div><div class="line">                reverse(&amp;s[front], &amp;s[i]);</div><div class="line">                front = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是方法是Leetcode网友分享的，思路也比较简单（类似这种方法，也可以用迭代器实现，不过可能有些许麻烦）</p>
<p><strong>Ps</strong> : 这道题如果用python，一行就能搞定 return “ “.join(map(lambda x: x[::-1], s.split())) </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 500. Keyboard Row</title>
    <link href="http://yoursite.com/2017/07/18/500.Keyboard_Row/"/>
    <id>http://yoursite.com/2017/07/18/500.Keyboard_Row/</id>
    <published>2017-07-18T04:38:22.087Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.(这里Image就不贴上来了，就是大多数键盘的布局)</p>
<a id="more"></a>
<p><strong>Example:</strong><br>Input: [“Hello”, “Alaska”, “Dad”, “Peace”]<br>Output: [“Alaska”, “Dad”]</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>暴力解决，逻辑可能会有些不清晰，不过比较简单直接</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row1 = &#123;<span class="string">'q'</span>,<span class="string">'w'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'t'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>&#125;;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row2 = &#123;<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row3 = &#123;<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>,<span class="string">'v'</span>,<span class="string">'b'</span>,<span class="string">'n'</span>,<span class="string">'m'</span>&#125;;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; rows = &#123;row1,row2,row3&#125;;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.size();i++)&#123;</div><div class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; rows.size();j++)&#123;</div><div class="line">                <span class="keyword">if</span> (rows[j].count((<span class="keyword">char</span>)<span class="built_in">tolower</span>(words[i][<span class="number">0</span>])) &gt; <span class="number">0</span>) row = j;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; words[i].size();k++)&#123;</div><div class="line">                <span class="keyword">if</span> (rows[row].count((<span class="keyword">char</span>)<span class="built_in">tolower</span>(words[i][k])) == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (k == words[i].size() - <span class="number">1</span>) res.push_back(words[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里使用unordered_set 这种数据结构（无序的集合，不可重复）。然后遍历每个单词，在内循环中找出每个单词第一个字母出现的行数（这里的行 指的是 键盘上的行，共有三行），最后再在遍历单词的每个字母，判断是否是每个字符都在同一行的情况，若是，往结果里添加相应的单词，否则选择忽略该单词，继续遍历或停止。</p>
<p><strong>Ps</strong> : 这里使用也可以使用set，但是注意在C++ 里 set 是用红黑树实现，插入时间和查找时间都是O(logN)，而unordered_set 使用 哈希表（散列表） 实现的，查询时间分摊后 大概是 O(1)，插入时间也是O(1)。对于本题，因为在集合里数据较少，所以当输入数据规模较大时，这两种数据结构之间的差异就比较明显了（主要是查找上），规模小的情况下，差异不大。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.(这里Image就不贴上来了，就是大多数键盘的布局)&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 496. Next Greater Element I</title>
    <link href="http://yoursite.com/2017/07/18/496.Next_Greater_Element_I/"/>
    <id>http://yoursite.com/2017/07/18/496.Next_Greater_Element_I/</id>
    <published>2017-07-18T04:38:22.086Z</published>
    <updated>2017-06-06T14:06:13.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>Output: [-1,3,-1]<br>Explanation:<br>    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br>    For number 1 in the first array, the next greater number for it in the second array is 3.<br>    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</p>
<blockquote>
<p>这里可能要说明一下题目，注意到下一个比它大的值，这里一旦找到第一个比它大的就停止了，即使后面有更大，也不需要了，这点很关键。</p>
</blockquote>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">while</span> (s.size() &amp;&amp; s.top() &lt; n) &#123;</div><div class="line">                <span class="built_in">map</span>[s.top()] = n;</div><div class="line">                s.pop();</div><div class="line">            &#125;</div><div class="line">            s.push(n);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : findNums) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.count(n) &gt; <span class="number">0</span>) </div><div class="line">                res.push_back(<span class="built_in">map</span>[n]);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                res.push_back(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>主要是使用栈和关联表这种数据结构，其实使用stack的目的就是保存数据，其实使用数组也可以，但是诸多不便。</p>
<p>这里根据题意就可以组织关联表了，比如上面那个例子中，仅仅建立当前值与栈顶值(即当前值之前所有未建立关系的值)的关联关系，具体的代码中很清晰了。有两个需要注意的地方，一是第一个for循环里的while循环，这里要不断拿当前值和栈中的值做比较，直到没有满足条件的值，二是map.count(n) ，如果直接使用map[n] 会导致添加无用的值。</p>
<p><strong>Ps:</strong> : 这题不能排序，因为顺序在这道题很重要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.&lt;/p&gt;
&lt;p&gt;The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 485. Max Consecutive Ones</title>
    <link href="http://yoursite.com/2017/07/18/485.Max_Consecutive_Ones/"/>
    <id>http://yoursite.com/2017/07/18/485.Max_Consecutive_Ones/</id>
    <published>2017-07-18T04:38:22.085Z</published>
    <updated>2017-06-08T08:37:07.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Note:</p>
<p>The input array will only contain 0 and 1.<br>The length of input array is a positive integer and will not exceed 10,000</p>
<a id="more"></a>
<p>Example:</p>
<p>Input: [1,1,0,1,1,1]<br>Output: 3<br>Explanation: The first two digits or the last three digits are consecutive 1s.The maximum number of consecutive 1s is 3.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">                maxcount = max(++count, maxcount);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                count = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxcount;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>基本算是暴力解法了，也有点动态规划的意思，有状态，有状态转移，求出最优解。</p>
<p>应该没有更好的解法了，因为怎么说都要遍历一遍数组，至少都是O(N).取最大值那块也许可以优化一下，如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">                ++count;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                maxcount = max(count, maxcount);</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max(count, maxcount);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样把取最大值放到了当n == 0 时，因为根据所求是连续的1，所以猜想数据有可能 1 的个数比 0 多，如果确是如此，那比较次数就能减少了。这种情况在庞大的数据里也是存在的，比如矩阵，经常是0比较多。</p>
<blockquote>
<p>以上两种方式（算不上两种方法），应根据数据特点选择使用。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a binary array, find the maximum number of consecutive 1s in this array.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;The input array will only contain 0 and 1.&lt;br&gt;The length of input array is a positive integer and will not exceed 10,000&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 476. Number Complement</title>
    <link href="http://yoursite.com/2017/07/18/476.Number_Complement/"/>
    <id>http://yoursite.com/2017/07/18/476.Number_Complement/</id>
    <published>2017-07-18T04:38:22.083Z</published>
    <updated>2017-06-06T14:05:09.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<a id="more"></a>
<p><strong>Exampe:</strong></p>
<p>Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p>
<h3 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = num;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</div><div class="line">            temp /= <span class="number">2</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        temp = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">            num = num ^ temp;</div><div class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路是先算出该整数的最大有效位数，通过不断除以2，计数直至该整数为0为止。然后就是核心部分了，使用异或运算，初始时使用1与之异或，然后左移变量(即代码中的temp)。最终即可得到答案。</p>
<p>这里还是举个例子吧，便于理解。比如要求的整数是5（二进制101，下同），我们先确定最大有效位数（即3），然后先做 1 ^ 5 (结果是100，即4)，接着1左移1位（010），注意此时整数已经被赋值为4了，紧接着4(100) 与 2 (010) 再异或，010 再左移，如此循环即可，最终返回num.</p>
<p><strong>Ps</strong>: 这里有更方便的方法，用bitset的 flip() 方法，直接翻转。最后再转换成整形即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 463. Island Perimeter</title>
    <link href="http://yoursite.com/2017/07/18/463.Island_Perimeter/"/>
    <id>http://yoursite.com/2017/07/18/463.Island_Perimeter/</id>
    <published>2017-07-18T04:38:22.081Z</published>
    <updated>2017-06-06T14:40:00.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<a id="more"></a>
<p>Example:</p>
<p>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p>
<p>Answer: 16</p>
<blockquote>
<p>求边数，注意公共边</p>
</blockquote>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="number">1</span>) repeatCount++;</div><div class="line">                    <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>] == <span class="number">1</span>) repeatCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="number">4</span> * count - <span class="number">2</span> * repeatCount;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>画出图后，找找规律应该很明白了，主要要减去重复的边数，值得注意的是数组不要越界，所以要有一定的检查，上面的代码采用的是取左上的方式，当然也可以是是右上，左下等等，只要是任意两边就行，为方便，故取左上（右下也挺方便的）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 461.Hamming Distance</title>
    <link href="http://yoursite.com/2017/07/18/461.Hamming_Distance.1/"/>
    <id>http://yoursite.com/2017/07/18/461.Hamming_Distance.1/</id>
    <published>2017-07-18T04:38:22.080Z</published>
    <updated>2017-06-05T06:33:04.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, calculate the Hamming distance.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Input: x = 1, y = 4</p>
<p>Output: 2</p>
<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<h3 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> n = x ^ y;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) </div><div class="line">                count++;</div><div class="line">            n &gt;&gt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最简单最暴力的方法应该就是直接做异或运算，然后统计运算结果的二进制表示有几个位是1.<br>具体的实现方法如代码，很容易理解。</p>
<p><strong>Note</strong>: 异或运算能解决不少问题，比如进位计算，交换值等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;461-Hamming-Distance&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance&quot;&gt;&lt;/a&gt;461. Hamming Distance&lt;/h1&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, calculate the Hamming distance.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 448. Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2017/07/18/448.Find_All_Numbers_Disappeared_in_an_Array/"/>
    <id>http://yoursite.com/2017/07/18/448.Find_All_Numbers_Disappeared_in_an_Array/</id>
    <published>2017-07-18T04:38:22.079Z</published>
    <updated>2017-06-09T13:21:16.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[5,6]</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</div><div class="line">            s.insert(n);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (s.find(i+<span class="number">1</span>) == s.end())</div><div class="line">                res.push_back(i+<span class="number">1</span>);</div><div class="line">                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个是比较容易想到的方法（比较直接）,思路是将所有碰到的下标放入一个无序无重复的set里，然后从1开始查找，如果不存在，就在结果里添加即可。时间复杂度就是O(N) 了，主要在循环插入和遍历元素上（unordered_set的插入时间和查找时间都是O(1)）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> m = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</div><div class="line">            nums[m] = nums[m]&gt;<span class="number">0</span> ? -nums[m] : nums[m];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) res.push_back(i+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法就有点技巧了。遍历nums数组,将对应下标（注意要减1才是对应下标）的元素设为负的，最后遍历nums数组找出是正的就行，这里要注意一下数组里元素比对应下标大1。这里时间复杂度也是O(N),但是没有额外的空间消耗（res那个数组是必须的），但是也有个弊端，如果题目要求不能改变原数组，为了继续用这种方法，就不得不复制一个数组（参数非引用即可），这样空间复杂度可能还不如第一种方法，因为第一种方法不保存重复的元素，根据此题，set的大小（不包括类的其他成员占的空间）肯定比原数组大小要小。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.&lt;/p&gt;
&lt;p&gt;Find all the elements of [1, n] inclusive that do not appear in this array.&lt;/p&gt;
&lt;p&gt;Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 389. Find the Difference</title>
    <link href="http://yoursite.com/2017/07/18/389.Find_the_Difference/"/>
    <id>http://yoursite.com/2017/07/18/389.Find_the_Difference/</id>
    <published>2017-07-18T04:38:22.077Z</published>
    <updated>2017-06-10T12:33:51.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<a id="more"></a>
<p>Example:</p>
<p>Input:<br>s = “abcd”<br>t = “abcde”</p>
<p>Output:<br>e</p>
<p>Explanation:<br>‘e’ is the letter that was added.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>使用哈希表，比较直接，不贴代码了。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</div><div class="line">            res ^= c;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t)</div><div class="line">            res ^= c;</div><div class="line">            </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实这道题和<a href="https://leetcode.com/problems/single-number/#/description" target="_blank" rel="external">这道题</a>简直就是异曲同工，两个相同的数做异或结果是0,0和任意数异或结果是该数，所以这里遍历两个字符串，最后结果单独的，即single-number。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given two strings s and t which consist of only lowercase letters.&lt;/p&gt;
&lt;p&gt;String t is generated by random shuffling string s and then add one more letter at a random position.&lt;/p&gt;
&lt;p&gt;Find the letter that was added in t.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 387. First Unique Character in a String</title>
    <link href="http://yoursite.com/2017/07/18/387.%20First%20Unique%20Character%20in%20a%20String/"/>
    <id>http://yoursite.com/2017/07/18/387. First Unique Character in a String/</id>
    <published>2017-07-18T04:38:22.076Z</published>
    <updated>2017-06-18T09:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<a id="more"></a>
<p>Example:<br>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</div><div class="line">            ++<span class="built_in">map</span>[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] == <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>直接使用map保存字符出现的次数，然后在遍历，若碰到正好只出现一次的情况，直接返回下标即可。注意这里直接使用了map []操作符是因为我们遍历的是同一个字符串，不会出现其他字符，所以不用担心会添加其他字符。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>其实也是 使用map，但是这时候要多保存一下索引，因为我们可能不希望遍历两次数组（数组太大）。代码就不贴了，不是很费劲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2017/07/18/226.Invert_Binary_Tree/"/>
    <id>http://yoursite.com/2017/07/18/226.Invert_Binary_Tree/</id>
    <published>2017-07-18T04:38:22.074Z</published>
    <updated>2017-06-11T10:51:16.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Invert a binary tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div></pre></td></tr></table></figure></p>
<p>to<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="第一种方法-递归"><a href="#第一种方法-递归" class="headerlink" title="第一种方法(递归)"></a>第一种方法(递归)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">        swap(root-&gt;left, root-&gt;right);</div><div class="line">        <span class="keyword">if</span> (root-&gt;left) invertTree(root-&gt;left);</div><div class="line">        <span class="keyword">if</span> (root-&gt;right) invertTree(root-&gt;right);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>递归的交换左子树和右子树，思路很简单，递归也不难理解。</p>
<h3 id="第二种方法-非递归"><a href="#第二种方法-非递归" class="headerlink" title="第二种方法(非递归)"></a>第二种方法(非递归)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    TreeNode* invertTree(TreeNode* root) &#123;</div><div class="line">        stack&lt;TreeNode *&gt; s;</div><div class="line">        s.push(root);</div><div class="line">        while (!s.empty()) &#123;</div><div class="line">            TreeNode *p = s.top();</div><div class="line">            s.pop();</div><div class="line">            if (p) &#123;</div><div class="line">                if (p-&gt;left) s.push(p-&gt;left);</div><div class="line">                if (p-&gt;right) s.push(p-&gt;right);</div><div class="line">                swap(p-&gt;left, p-&gt;right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用栈作为暂时存储容器（也可以用队列，这里对于顺序不敏感）,分别交换栈顶节点的左子树和右子树（即使为空）.</p>
<p><strong>Ps:</strong> : 对于树的问题，往往既可以用递归，也可以用循环来解决，经常也是递归代码比较简洁，但有时候可能比较难以理解，循环往往比较容易理解。值得注意的是，系统的栈深度是有上限的（虽然可以调，但是付出的代价不小），如果树的深度值太大，很有可能会出现栈内存不够用的情况，从而导致程序崩溃（而且在有点情况下，直到程序运行了一段时间才能发现这个问题）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Invert a binary tree.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;     4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   /   \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  2     7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; / \   / \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1   3 6   9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;to&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;     4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   /   \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  7     2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; / \   / \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9   6 3   1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 198. House Robber</title>
    <link href="http://yoursite.com/2017/07/18/198.%20House%20Robber/"/>
    <id>http://yoursite.com/2017/07/18/198. House Robber/</id>
    <published>2017-07-18T04:38:22.073Z</published>
    <updated>2017-07-07T09:36:32.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<blockquote>
<p>简单来说就是求数组中不相邻元素的最大和序列</p>
</blockquote>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxRob = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = max(pre + nums[i], maxRob);</div><div class="line">            pre = maxRob;</div><div class="line">            maxRob = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxRob;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>动态规划的思想（上篇文章讲到过），所以得找到三个要素，分别是最优子结构，状态转移方程，边界。</p>
<p>先假设一个函数F(N)，N代表N个数据（N个房子）,F（N）就是N个数据的序列。</p>
<p>通过分析，不难得出我们想要得到F(N)，可以先求出F(N-1)，然后取F(N-1)的最大值即可。<br>所以max(sum(F(N-1))) 应该就是F(N) 的最优子结构，从而可以得到状态转移方程: <strong>F(N)=max(sum(F(N-1)))</strong>，边界条件不难，就是F(1) = 序列首元素。</p>
<p>最后即可写出上述代码。</p>
<blockquote>
<p>注意上述方程中sum() 并不是简单的累加求和。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说就是求数组中不相邻元素的最大和序列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题： 169. Majority Element</title>
    <link href="http://yoursite.com/2017/07/18/169.%20Majority%20Element/"/>
    <id>http://yoursite.com/2017/07/18/169. Majority Element/</id>
    <published>2017-07-18T04:38:22.071Z</published>
    <updated>2017-06-18T10:28:15.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<a id="more"></a>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</div><div class="line">            <span class="built_in">map</span>[n]++;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> N = nums.size() / <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : <span class="built_in">map</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p.second &gt; N)</div><div class="line">                <span class="keyword">return</span> p.first;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>直接使用map统计出现次数，最后返回出现次数大于2/n的键就行了。很简单，重点看看第二种方法。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> majorityIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">1</span>; i &lt; num.size(); i++) &#123;</div><div class="line">            num[majorityIndex] == num[i] ? count++ : count--;</div><div class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                majorityIndex = i;</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">return</span> num[majorityIndex];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是Leetcode网友给出的解答，使用了Moore’s voting algorithm（摩尔投票算法），在这大致说一下，遍历数组，和当前majorityIndex的数做比较，如果一样就让计数器加1，不同则减1，若count减到0了（说明这个下标索引的肯定不是最终结果）,就重新让count=1，majorityIndex = i(即另取一个值)，最后返回这个下标索引的值即可。</p>
<p>关于摩尔投票算法，可以看看这篇文章  <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm</a></p>
<p>还有这个website，可以试试<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/" target="_blank" rel="external">https://www.cs.utexas.edu/~moore/best-ideas/mjrty/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode 解题报告" scheme="http://yoursite.com/categories/Leetcode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
